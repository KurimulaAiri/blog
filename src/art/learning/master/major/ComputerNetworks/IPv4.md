---
title: IPv4
date: 2025-07-24
icon: 'earth-americas'
order: 21
category: 
    - '408'
    - '计算机网络'
    - 考研
---

## IPv4 协议

![各层协议之间关系](//store.s1r0ko.top/svg/m/cn/21/1_ver_1.svg)

::: tip

各层协议之中， **IP 协议（Internet Protocol）是互联网的核心**{#red-msg}

[ARP 协议](./IPv4.html#arp-协议)用于查询同一网络中的 `<主机 IP 地址, MAC 地址>` 之间的映射关系

[ICMP 协议](./IPv4.html#icmp)用于网络层实体之间互相通知“异常事件”

IGMP 协议用于实现 IP 组播

:::

## IP 数据报的格式

![IP 数据报的格式](//store.s1r0ko.top/svg/m/cn/21/2_ver_2.svg)

IP 数据报分为**首部**和**数据部分**两个部分

首部的结构如图所示

::: info 首部

首部分为固定部分和可变部分两个部分

固定部分长度为 **20 字节**，可变部分长度为 **0 ~ 40 字节不等**

各部分详解：

- 固定部分

| 字段名 | bit 位数 | 说明 |
| ---- | ---- | ---- |
| 版本 | 4 | 用于区分网络层使用的 IP 协议版本，使用二进制表示 4 就是 IPv4 协议，使用二进制表示 6 就是 IPv6 协议 |
| 首部长度 | 4 | 用于指示 IP 数据报的首部长度，单位为 4B，例如：一个首部长度为 20 B 的 IP 数据报，这里的内容为二进制表示的 5 即 $5 \times 4B = 20B$ |
| ~~区分服务~~ | 8 | ~~一般用不到， 408 不考~~ |
| 总长度 | 16 | 表示范围 0 ~ 65535 单位为 1B ，表示整个 IP 数据报的长度（首部 + 数据部分） |
| 标识 | 16 | 由 IP 数据报的“源主机”生成，通常是自增序列，相当于一个数据报的识别码，数据报进行分片时，各分片的标识码必须相同 |
| 标志[^1] | 3 | 三个 bit 分别为三个不同含义，最低位 MF 、 次低位 DF 、 最高位不需要了解意思，具体指代详见脚注 1，假设一个标志位为 001 则分别为最高位、 次低位 MF 、 最低位 DF |
| 片偏移 | 13 | 表示该数据部分在“被分片”之前所处的位置，以 8 B 为单位 |
| 生存时间 | 8 | 代表该数据报在网络中可通过的路由器数的最大值。常记为 TTL[^2] |
| 协议 | 8 | 表示当前数据报正在为哪一个协议服务，如果是 TCP 该值设置为 6 、 如果是 UDP 该值设置为 17 |
| 首部校验和 | 16 | 经过的每个路由器都会对首部进行校验（不校验数据部分），如果该字段全设为 0 ，表示不用校验；校验和的计算方法与 UDP 相同 |
| 源地址 | 32 | 发送主机的 IP 地址 |
| 目的地址 | 32 | 接收主机的 IP 地址 |

[^1]: 标识位含义对照表：
    | 标志位 | 值 | 含义 |
    | --- | --- | --- |
    | MF | 0 | 表示当前分片是 IP 数据报的最后一个分片 |
    | MF | 1 | 表示当前分片不是 IP 数据报的最后一个分片，后面还有分片 |
    | DF | 0 | 表示 IP 数据报可以进行分片 |
    | DF | 1 | 表示 IP 数据报不能进行分片 |

[^2]: 生存时间 TTL ：
    - TTL 的初始值通常由源主机设置
    - 每经过一个路由器， TTL 就会减 1
    - 当 TTL 减为 0 时，该数据报就会被丢弃，并且向源主机发送 ICMP 报文代表发生异常发送失败

- 可变部分

| 字段名 | bit 位数 | 说明 |
| --- | --- | --- |
| 填充 | 不定长 | 用于将 IP 数据报首部填充至 4B 的整数倍 |

:::

::: info 数据部分

数据部分长度范围：0 B ~ ( 65535 - 20 ) B ，扣掉的 20 B 为首部的最小长度，值不需要记

上面只是受到首部总长度字段的限制，也就是**理论最大值**，实际上 IP 数据报的长度通常会受到数据链路层的最短 / 长帧长的限制

:::

一个数据链路层数据帧能承载的最大数据量称为最大传输单元（MTU）。如[以太网帧](./LocalAreaNetwork.html#v2-标准的以太网-mac-帧) MTU = 1500 B

如果一个 IP 数据报总长度超出了下一段链路的 MTU 就需要进行分片处理，依次传递这些分片给下一个节点

拆分时需要注意需要按 MTU 大小减去 IP 数据报的首部长度，得到的数据部分长度才是分片后的数据长度

::: warning

- IP 数据报的“分片”可能在源主机或任何一个路由器中发生

- 只有目的主机才会对分片进行 **“重组”**

- 各分片有可能以乱序到达目的主机

- 由于首部“片偏移”字段是以 **8 B** 为单位，因此，除**最后一个分片**外，其他每个分片的数据部分必须是 **8 B** 的整数倍

- **当标志位 DF = 1 且下一段数据链路层数据帧长也无法满足这一份数据报时，路由器会选择丢弃该数据报，并且向源主机发送 ICMP 报文代表发生异常发送失败**{#red-msg}

- 4 1 8，首部长度 4B 为单位，总长度 1B 为单位，片偏移 8B 为单位

:::

## IP 地址详解

IP 地址是一个 32 位的二进制数，通常用点分十进制的形式表示，例如： 192.168.1.1

IP 地址资源由 ICANN（互联网名字与数字分配机构）进行分配（有偿分配）

ICANN 将 IP 地址分为以下几类（如图）：

![IP 地址分类](//store.s1r0ko.top/svg/m/cn/21/3_ver_1.svg)

::: info IP 地址

一个 IP 地址由两部分组成： 网络号 + 主机号

这两个号不定长，需要根据不同种类的 IP 地址而定

| IP 地址类型 | 网络号长度 | 主机号长度 | 网络号前几位固定位 | 前八位表示的十进制数范围 |
| --- | --- | --- | --- | --- |
| A 类 | 8 位 | 24 位 | 0 | 0 ~ 126 |
| B 类 | 16 位 | 16 位 | 10 | 128 ~ 191 |
| C 类 | 24 位 | 8 位 | 110 | 192 ~ 223 |
| D 类 | 无 | 无 | 1110 | 224 ~ 239 |
| E 类 | 无 | 无 | 1111 | 240 ~ 255 |

:::

::: warning

- 在早期互联网时代，每台主机，每个路由器接口被分配的 IP 地址都是全球唯一的

- 路由器和路由器连接的接口可以不分配 IP 地址，但路由器和其他节点连接的接口必须分配 IP 地址

- 从属于同一个网络的所有主机、路由器接口和 IP 地址“网络号”都相同

- 当一台新主机接入网络时，需要给他分配一个 IP 地址、并配置“默认网关”

:::

- 单播地址：每一个 IP 对应一台主机

- 多播地址：每一个 IP 可以分配给一个主机群，向一个多播地址发送信息，就是向这一群主机发送信息

### IP 转发示例

假设有如下网络拓扑：

![IP 转发示例](//store.s1r0ko.top/svg/m/cn/21/4_ver_2.svg)

- 某学校被分配的 IP 网络号为 `166.1.0.0`

- 某公司被分配的 IP 网络号为 `200.1.1.0`

现有一个 IP 数据报从 H1 发送到 H7，结构如下：

| 源 IP | 目的 IP | 
| --- | --- | 
| 166.1.0.1 | 200.1.1.2 | 

过程大致如下：

1. H1 完成数据报的组装后比较网络段和自身网络段是否处在一个局域网内，发现不是，所以发往网关（每个节点都会保存该局域网的网关 IP ），组帧需要目的 MAC 地址，通过 [ARP 协议](./IPv4.html#arp-协议)可以根据节点内部的网关 IP 获取到网关 MAC 地址，完成组帧后发往连接该节点的交换机

2. 交换机获取到 MAC 帧后，会根据 MAC 转发到网关

3. 网关收到多个 MAC 帧并完成组装 IP 数据报后，会根据目的 IP 地址查询转发表转发到对应端口

4. 根据图片可知，此时学校网关有到达目的网段的路由，所以会将数据报发往该路由，发往公司的网关

5. 公司路由器收到该数据报，确认是发往公司网段，此时通过组帧可以获取到目标 IP 主机的 MAC 地址，发送 MAC 帧发往公司的交换机

6. 交换机确认 MAC 地址，发送到对应主机

现有一个 IP 数据报从 H1 发送到 H6，结构如下：

| 源 IP | 目的 IP | 
| --- | --- | 
| 166.1.0.1 | 166.1.4.4 | 

1. H1 组装完数据报后，检查到目的 IP 和自己处于同一个网段中，于是通过 [ARP 协议](./IPv4.html#arp-协议)获取到目的 IP 主机的 MAC 地址，组帧后发往交换机

2. 交换机收到数据报后，会根据 MAC 地址直接转发到 H6 或下一个交换机节点，直到到达目的主机

3. 到达目的主机后，目的主机会先检查 MAC 地址是否是自己，确认后组装成 IP 数据报，再确认目的 IP 地址是否是自己，确认后转交给上一层处理

### 一些特殊用途的 IP 地址

| 网络号 | 主机号 | 是否可以作为分组源地址 | 是否可以作为分组目的地址 | 含义 |
| --- | --- | --- | --- | --- |
| Y | 全 0 | **否**{#red-msg} | **否**{#red-msg} | 表示整个网络本身（仅能用于路由表、转发表） |
| Y | 全 1 | **否**{#red-msg} | **是**{#blue-msg} | 向网络号为 Y 的网络广播 IP 分组 |
| 0 | Y | **是**{#blue-msg} | **否**{#red-msg} | 表示本网络中主机号为 Y 的主机 |
| 全 0 | 全 0 | **是**{#blue-msg} | **否**{#red-msg} | 本网络上的本主机（ DHCP 协议中会使用） |
| 全 1 | 全 1 | **否**{#red-msg} | **是**{#blue-msg} | 向本网络广播 IP 分组 |
| 127 | 非全 0 或非全 1 的任何数 | **是**{#blue-msg} | **是**{#blue-msg} | 环回自检地址，表示一台主机本身，用于本地软件的环回测试 |

::: warning 

- 以上这些特殊地址不能指派给网络中的任何一台主机或路由器“私用”

- 主机号占 N bit ，那么这个网络中最多支持 $2^N - 2$ 个主机或路由器

:::

## 子网划分和子网掩码

假设以下情况：

- 某学校被分配 B 类地址段 `166.1.0.0` ，并且使用**子网划分技术**分配两个子网

- 某公司被分配 C 类地址段 `200.1.1.0` 

如图：

![子网划分](//store.s1r0ko.top/svg/m/cn/21/5_ver_2.svg)

子网划分通过将主机位前 N 位拿出来作为子网号，将主机位后 M 位拿出来作为主机号，来实现子网的划分

比如此图就是将主机位第一位作为子网位，因此可以分为两个子网

假设有以下几种情况，分析数据传输过程

- **H3 向 H6 发送数据报（同一子网内的两台主机）**

H3 在发送数据之前，构造完 IP 数据报后，会将源 IP 地址和目的 IP 地址与子网掩码进行“与运算”，并对结果进行对比，发现网络前缀相同，说明 H6 和 H3 位于同一个子网下，随后可以直接生成 MAC 帧，找到 H6 的 MAC 地址，直接发送给交换机进行转发，到达 H6 后， H6 会将 MAC 组装成 IP 数据报，对比发现目的地址是自己，就接收数据

- **H1 向 H3 发送数据报（不同子网内的两台主机）**

H1 构建数据报之后计算对比发现，源地址和目的地址不在一个子网内，会通过 [ARP 协议](./IPv4.html#arp-协议)获取到路由器的 MAC 地址，于是组装 MAC 帧发往路由器；路由器收到并完成组装数据报后，会对目的 IP 地址使用转发表进行计算，得到网络前缀后查询转发表，发现目的网络前缀在特定接口，于是发往对应接口，目的主机 MAC 地址通过 [ARP 协议](./IPv4.html#arp-协议)得到，到达交换机后，传输给 H3 

- **H1 向 H7 发送数据报（采用子网划分技术的网络向传统网络发送）**

对于有子网划分技术的路由器在存转发表时，对于连接传统路由器的接口，需要将 **子网掩码项设置为“默认子网掩码”** 不同类型的网络需要配置不同的子网掩码，具体在下面思维导图的表格中，这样才能正确地将数据报转发到传统网络中，这里 H1 向路由器发送数据报，路由器比对后发现由 B0 接口发出，然后到达公司路由器，该传统路由器识别出目的地址的网络类型 （ A / B / C ） 类，并将对应的网络号拆分出来，与交换表进行比对，确定为在本局域网内，通过 [ARP 协议](./IPv4.html#arp-协议)得到目的主机 MAC 地址，交由交换机，最后到达目的主机

- **H7 向 H1 发送数据报（传统网络向采用子网划分技术的网络发送）**

H7 完成数据报的封装，对目的地址进行检查，发现不在自己的网络内，于是将数据报发往路由器，路由器根据其网络类型切分网络号，查询交换表后发往对应接口，到达学校路由器后，路由器使用子网掩码进行一一计算，得到对应的子网端口，并通过 ARP 获取目的主机的 MAC 地址发送给交换机最后到达目的地址

- **主机 H1 发往 Internet 的某个 IP 数据报如何传输？ （假设目的 IP 地址为 111.2.3.4）**

H1 使用子网掩码计算自己和目的 IP 地址，发现不在同一个网络，于是将 IP 数据报通过 MAC 地址发往网关，网关收到数据报后，使用各子网掩码对目的地址进行计算，发现目的地址不在自己的路由表内，于是发往默认路由（0.0.0.0）也就是 B1 ，到达 ISP 后， ISP 路由器也进行计算比对发现也不在自己的路由表内，于是发往其他，也就是 A1 最后经过层层路由器转发会最终到达 Internet 的某一节点

```markmap
---
markmap:
  colorFreezeLevel: 4
  maxWidth: 400
---

# 子网划分技术

## 子网划分

### 原理

- 若某单位租用了一个 IP 地址段，假设原本主机号占 $n$ bit 那么可以将前 $k$ bit 扣出来当**子网号**，用剩余的 $n - k$ bit 作为**主机号**，这样就能划分出 $2^k$ 个子网（每个子网包含的 IP 地址块大小相等）

### 子网划分前后 IP 结构变化

- 划分前：**两级结构**

    - <网络号, 主机号>

- 划分后：**三级结构**

    - <网络号, 子网号, 主机号>

### 注意

- 每个子网地址中，主机号**不能分配为全 0 或全 1** —— 全 0 代表子网自身，全 1 代表子网广播地址

## 子网掩码

### 作用

- 用子网掩码、 IP 地址“逐位进行与运算”，算出 **<网络号, 子网号>** （可合称“网络前缀”）

- 只有网络前缀相同的 IP 地址，才归属于同一个网络（子网）

### 注意

- 如果一个网络内部**进行了子网划分**，那么这个网络中的**每台主机、每个路由器接口**都需要配置 **IP 地址、默认网关、子网掩码**

- 如果一台路由器支持子网划分技术，那么在它的转发表中，需要包含 <目的网络号, 子网掩码, 转发接口> 这三个字段

## 默认子网掩码

- 如果一个传统网络（ A / B / C 类）内部**没有进行子网划分**，那么可以将对应此网络的转发表**子网掩码项设置为“默认子网掩码”**

    - | 网络类别 | 默认子网掩码 |
      | --- | --- |
      | A 类 | 255.0.0.0 |
      | B 类 | 255.255.0.0 |
      | C 类 | 255.255.255.0 |

## 默认路由

### 默认路由（默认转发表项）设置：<目的网络号全为 0 , 子网掩码全 0 >

### 在路由转发表中，如果所有表项都不匹配，那么将由**默认路由**转发出去

```

### 主机发送数据报的过程

1. 判断目的主机和本机是否属于同一个网络

    1. 检查本机 IP 地址和目的 IP 地址的网络前缀是否相同（需要用本机配置的子网掩码进行“逐位与”运算）

    2. 若两个网络前缀相同，说明目的主机和本机属于同一个网络；若网络前缀不同，说明不属于同一个网络

2. 将 IP 数据报封装成 MAC 帧并发送到链路上

    1. 如果目的主机与本机**属于同一个网络**，就通过 [ARP 协议](./IPv4.html#arp-协议)找到**目的主机**的 MAC 地址，再将 IP 数据报封装成帧，并将帧转发给**目的主机**

    2. 如果目的主机与本机**不属于同一个网络**，就通过 [ARP 协议](./IPv4.html#arp-协议)找到**默认网关**的 MAC 地址，再将 IP 数据报封装成帧，并将帧转发给**默认网关**

### 路由器转发数据报的过程

1. 从路由器某个接口收到一个 IP 数据报

2. 对 IP 数据报首部进行校验，并从中找到**目的 IP 地址**

3. 查“转发表”

    1. 转发表项包含<目的网络号, 子网掩码, 转发接口>

    2. 检查目的 IP 地址与每个表项是否匹配（将目的地址、子网掩码“逐位与”运算，若结果和某个目的网络号相同，说明匹配）

    3. 最后一定会和默认路由匹配（默认路由的子网掩码为 0.0.0.0 所有 IP 和其进行“逐位与”运算，结果都为 0.0.0.0），并转发出去

4. 转发

    1. 根据查找转发表的结果，将 IP 数据报从对应的接口转发出去

    2. 如果匹配的转发接口和该 IP 数据报的入口相同，就不会再将该数据报转发回去

::: tip

在一个局域网内有多个子网的情况下，可以使用多个路由器进行相互连接，可以降低路由器的负载，提升数据传输效率，只有**一个**路由器负责和外界互联网通信，这样的局域网称为一个自治系统（AS）

:::

### CIDR

CIDR （Classless Inter-Domain Routing），无类别域间路由选择协议也称无分类编址，是一种用于分配 IP 地址和路由信息的协议，它的作用是**减少 IP 地址的浪费**，并**提高路由效率**

在上世纪 90 年代，对于每台主机一个全球唯一的 IP 地址的要求，导致 IP 地址资源告急，为了使 IP 地址资源得到更好的利用，CIDR 出现了

CIDR 表示法：<IP 地址>/<前缀长度>

前缀长度，代表 IP 地址的二进制表现形式下前 $N$ 位为网络地址即其子网掩码为前 $N$ 位为 1 后 $24 - N$ 位为 0

例如：192.168.1.0/24 表示 192.168.1.0 到 192.168.1.255 这 256 个 IP 地址，其中 24 位表示网络号，8 位表示主机号

假设此时有一个企业需要给 2000 台主机分配 IP 地址，直接分配一个 B 类地址会导致浪费过多，可以使用 CIDR 分配 21 bit 作为网络号（x.x.x.0/21），剩下 11 bit 作为主机号， 11 bit 的主机号可以分配 $2^{11}$ 个主机，也就是 2048 个主机，使网络分配更加精准

对于分配到 CIDR 地址块后可以再次将其划分为多个子网，这里有两种划分方式

- **定长子网划分**

在一个 CIDR 地址块中，把长 $n$ 的主机号前 $k$ bit 抠出来作为定长子网号，这样就能划分出 $2^{k}$ 个子网（每个子网包含的 IP 地址块大小相等，每个 IP 地址块大小为 $2^{n - k}$ ）

缺点：每个子网的 IP 地址块大小相同，不能根据需求灵活调整，会导致 IP 地址资源的浪费

![变长子网划分示例](//store.s1r0ko.top/svg/m/cn/21/6_ver_1.svg)

- **变长子网划分**

在一个 CIDR 地址块中，划分子网时，**子网号长度不固定**（每个子网包含的 IP 地址块大小不同）

::: tip CIDR 地址块的子网划分技巧：可以利用类似“[从根到叶构造二叉哈夫曼树](http://test.com/123.html)”的技巧

- 原始 CIDR 地址块作为根节点（假设可以自由分配的主机号占 $h$ bit）

- 每个分支节点必须同时拥有左右孩子，左 0 右 1 （反过来也行）

- 每个叶子结点对应一个子网，根据根节点到达叶子结点的路径来分析子网对应的 IP 地址块范围

- 整棵树的高度不能超过 $h - 1$ （因为即便最小的子网也至少要保留 2 bit 主机号）

:::

例题：若将 101.200.16.0/20 划分为 5 个子网，则可能的最小子网的可分配 IP 地址数是（）

- A. 126

- **B. 254**{#blue-msg}

- C. 510

- D. 1022

## 路由聚合

根据上面 CIDR 分配的子网得到的拓扑如下：

![路由聚合示例](//store.s1r0ko.top/svg/m/cn/21/7_ver_1.svg)

由图可见 R0 的路由转发表许多网段都具有相同的网络前缀，并且转发至同一接口，因此这里可以使用路由聚合来合并这几个路由表项，将它们合并为一个路由表项，即 101.200.16.0/20 指向 R0 的接口，这样就可以减少路由表项的数量，提高路由效率

![路由聚合示例](//store.s1r0ko.top/svg/m/cn/21/8_ver_1.svg)

对于一个路由转发表，如果几条路由表项的**转发接口相同**{#red-msg}，**部分网络前缀也相同**{#red-msg}，那么可以将这几条路由表项聚合为一条。这种地址的聚合称为**路由聚合**，也称为**构成超网**

路由聚合的优缺点：

- 优点

    - 可以减小路由表的大小

    - 提高了路由查找效率

- 缺点

    - 可能会引入额外的无效地址，比如前缀和已分配 IP 地址相同，但是还未分配的 IP 地址；就有可能出现因意外导致填错的 IP 地址转发到未使用的 IP 地址，但是后续的路由器可能无法找到这个 IP 地址，于是会发往默认路由，也就是又返回给发送方，但是路由器对于发往来时路的数据报会直接丢弃，最后这个数据报就不会被任何节点接收，但通常不会有太大影响

现在交换机 S1 上单独拉一条线直接连接 R0 ，此时更新 R0 交换表，会出现两个具有共同网络前缀的网段，当传来一个前往 C2 的数据报时， R0 会遵循最长前缀匹配原则，即选择最长的前缀匹配项，即 128.14.32.128/28 不经过 R1 直接到达 S1

![路由聚合示例](//store.s1r0ko.top/svg/m/cn/21/9_ver_1.svg)

## 子网划分综合示例

![子网划分综合示例](//store.s1r0ko.top/svg/m/cn/21/10_ver_2.svg)

通过这张图自行进行 IP 数据报的发送与接收训练

## 网络地址转换 NAT

NAT （Network Address Translation），网络地址转换，是一种将私有 IP 地址转换为公共 IP 地址的技术，也可以将公共 IP 地址转换为私有 IP 地址的技术

该小节重点

```markmap
---
markmap:
  colorFreezeLevel: 4
  maxWidth: 300
---

# 网络地址转换 NAT

## 私有 IP 地址（内网 IP ） 

### 各类私有 IP 地址块

- | 类别 | IP 地址范围 |
  | :---: | :---: |
  | A 类 | 10.0.0.0 ~ 10.255.255.255 |
  | B 类 | 172.16.0.0 ~ 172.31.255.255 |
  | C 类 | 192.168.0.0 ~ 192.168.255.255 |

    - 只允许分配给局域网内部的节点，不允许分配给互联网上的节点

### 每个局域网内部都可以自行分配这些私有 IP 地址

### 私有 IP 地址是可复用的，只要求局域网内唯一，不要求全球唯一

## 全球 IP 地址（外网 IP ）

### 通常由 ISP 提供，全球唯一

### 外网 IP 是一个局域网与外界通信时所需要使用的 IP 地址

## NAT 路由器

### 作用：转发 IP 数据报时，进行内网、外网 IP 的相互转换

### NAT 表，记录地址转换关系

- `<内网 IP :端口号, 外网 IP :端口号>`

### 一个 IP 数据报

- 从内网转发到外网，会更改源 IP 地址、源端口号

- 从外网转发到内网，会更改目的 IP 地址、目的端口号

### NAT 路由器包含传输层的功能（端口号是传输层的概念）

```

普通路由器和 NAT 路由器的区别：

- 普通路由器转发数据报时不会改变源 IP 地址或目的 IP 地址

- 普通路由器仅包含网络层以及以下的功能

### 端口号的概念

IP 地址指向某一台主机，而端口号指向该主机上的一个进程或应用程序

传输层实现了“端到端”（进程到进程）的通信。传输层在 TCP （或 UDP ）报文段的首部，指明源端口，目的端口

### NAT 路由示例

假设有以下路由结构：

![NAT 路由示例](//store.s1r0ko.top/svg/m/cn/21/11_ver_1.svg)

其 NAT 表如图所示

思考以下过程：

- **C3 向 C2 微信发送文字信息**

1. 假设 C3 向 C2 发送一条消息“你好”，此时这个文字信息是应用层数据，进入传输层假设使用 TCP 传输协议，那么传输层需要在在数据前添加一个头部，包含源端口和目的端口，此时源端口写明的是 9855 ，而目的端口号不能直接写对方微信所在主机的端口（ 6666 ），因为其是隐藏的；这里目的端口需要写对方微信进程所在的 NAT 路由器对外暴露的端口号即 4096，至于这里的端口是如何被 C3 所知不作过多讨论，总之有方法可以获取到对方的端口号，此时数据段就封装好了

2. 到达网络层填写源 IP 地址为 C3 的 IP 地址（ 192.168.3.48 ），目的 IP 地址应该为 C2 的 IP 地址，但是 C2 是在 NAT 路由器上，所以需要填写的是 NAT 路由器的 IP 地址，即 66.211.88.55 

3. 完成网络层的封装后检查发现不属于本地局域网，封装填写默认网关 MAC 地址的帧，发送给默认网关

4. 默认网关为 NAT 路由器，数据报到达 NAT 路由器后，会根据 NAT 表进行地址转换，此时根据源 IP 和端口（ 192.168.3.48:9855 ），查表得到对应的公网 IP 地址和端口（ 59.175.49.153:7788 ）并将原 IP 地址和端口修改成这个（此时再次确定了 NAT 需要传输层的功能，因为其需要修改传输层数据段的端口号）

5. 经过互联网的层层转发，数据报到达 C2 的 NAT 路由器，根据 NAT 表进行地址转换，此时根据目的 IP 和端口（ 66.211.88.55:4096 ），查表得到对应的内网 IP 地址和端口（ 192.168.3.74:6666 ）并将原 IP 地址和端口修改成这个

6. 根据自身的路由表查找到局域网对应 IP 的接口转发出去，最终到达 C2 ，C2 收数据报后，确认自己的 IP 和端口，并接收数据，拆解数据报到达应用层


- **C2 向 C3 微信发送图片信息**

1. 自行思考

- **C5 向 Server 请求网页数据**

1. C5 封装数据报，设置源 IP 和端口：192.168.3.74:2111 和目的 IP 和端口：200.1.1.4:80 ，完成封装后发往默认网关

2. 网关根据 NAT 表修改源 IP 地址和端口： 59.175.49.153:23333 发送到互联网上

3. 数据直接由于 Server 所在的局域网没有使用 NAT 可以直接发送到对应主机的对应端口上，这里是交由 80 端口的 web 服务器进程对请求进行处理

- **Server 向 C5 返回网页数据**

1. 自行思考

## ARP 协议 

ARP （Address Resolution Protocol），地址解析协议，用于在本地局域网中根据 IP 地址找到对应的 MAC 地址

对于 ARP 协议，封装的网络层数据单元称为 ARP 分组，到达数据链路层也将使用 MAC 帧进行传输，但是 MAC 帧的协议部分字段需要写为 0x0806 ，表示该帧数据部分为 ARP 的 PDU

```markmap
---
markmap:
  colorFreezeLevel: 4
  maxWidth: 300
---

# 地址解析协议 ARP 

## 回顾

### **MAC 地址（ 48 bit ）** ，是网络适配器出厂时分配好的，全球唯一

### 一台主机至少有一个网络适配器（网线插口背后的芯片），因此**主机至少有一个 MAC 地址**

### 一台路由器有多个转发接口，每个接口背后都是一个网络适配器，因此**路由器至少有多个 MAC 地址**

## ARP

### 作用

- 在**一个局域网内**，可以**通过 ARP 协议查询到一个 IP 地址对应的 MAC 地址**

### ARP 表（ ARP 缓存）

- 记录（ IP 地址和 MAC 地址）之间的映射关系

- 一个数据结构（每台主机、每台路由器都有自己的 ARP 表）

- 需要定期更新 ARP 表项

### 过程

#### 1.ARP 请求分组

- 内容

    - 我是谁？

        - 我的 IP 地址是 X ，我的 MAC 地址是 Y

    - 我想找谁？

        - 我想找的这个家伙， IP 地址是 Z 

- ARP 请求分组封装进 MAC 帧（帧目的地址为全 1 ，源地址为 Y ）

    - **这是一个广播帧**

#### 2.ARP 响应分组

- 内容

    - 你好，我就是你要找的那个靓仔，我的 IP 地址是 Z ，我的 MAC 地址是 V 

- ARP 响应分组封装进 MAC 帧（目的地址为 Y ，源地址为 V ）

    - **这是一个单播帧**

```

### ARP 的工作流程

一般一台设备刚接入局域网时，他的 ARP 表是空的

假设现有网络拓扑如图：

![ARP 工作流程](//store.s1r0ko.top/svg/m/cn/21/12_ver_1.svg)

考虑以下流程：

- **H3 想向 Internet 发送 IP 数据报，分析 ARP 工作过程**

1. 由于此时 H3 的 ARP 表为空，目的 IP 地址位于局域网之外，此时需要将数据报交由路由器处理，此时虽然拥有默认网关的 IP 地址，但是没有其对应发 MAC 地址，因此首先需要通过 ARP 协议获得路由器的 MAC 地址

2. H3 构造 ARP 请求分组，指明源 IP 地址和 MAC 地址以及目的 IP 地址，这里为

| 源 IP 地址 | 源 MAC 地址 | 目的 IP 地址 |
| --- | --- | --- |
| 166.1.128.2 | AA:BB:CC:DD:EE:33 | 166.1.128.1 |

向下封装 MAC 帧，并将目的 MAC 地址设定为全 1 ，并进行发送

3. 通过广播，路由器接收到 ARP 请求分组，并分析确认接收方为自己，因此构造 ARP 响应分组，写入自身的 IP 地址和 MAC 地址，封装为目的 MAC 地址为 ……:33 的**单播帧**，并发送给 H3 ，并将 H3 的 IP 地址和 MAC 地址添加到 ARP 表中

4. H3 收到 ARP 响应分组，确认目的 IP 地址和 MAC 地址，将获得的 MAC 地址对应 IP 地址写入 ARP 表中，得到的结果如下图

![ARP 拓扑](//store.s1r0ko.top/svg/m/cn/21/13_ver_3.svg)

5. 获取到默认网关的 MAC 地址后，就继续之前的工作，向 Internet 上的某节点发送数据报

- **基于上一个情况，假设有一个 IP 数据报从 Internet 发送至 H3 ，分析 ARP 工作过程**

1. 路由器接收到这个来自互联网的数据报，检查其目的地址根据**路由转发表确认转发接口**，并**查询 ARP 表封装 MAC 帧**发送到该接口上（由于上一步已经确认了 H3 的 MAC 地址并写入路由器 ARP 表，因此这里不需要进行 ARP 通信）

- **H3 向 166.1.150.1 发送 IP 数据报，分析 ARP 工作过程**

1. 自行分析

## DHCP 协议

```markmap
---
markmap:
  colorFreezeLevel: 4
  maxWidth: 750
---

# 动态主机配置协议 DHCP

## 基本概念

### DHCP 协议的作用：给刚接入网络的主机动态分配 IP 地址、配置默认网关、子网掩码

### DHCP 使用客户/服务器模型（ C / S ）

- DHCP 客户：就是新接入网络的主机（希望获得 IP 地址等配置）

- DHCP 服务器

    - 就是负责分配 IP 地址的那台主机，管理一系列 IP 地址池

    - 注：在家庭网络中，通常由家庭网络路由器兼职“ DHCP 服务器”

    - 在一个大型网络内可以有多台 DHCP 服务器 

### **DHCP 是应用层协议，基于 UDP** 

- 客户 UDP 端口号：68、服务器 UDP 端口号：67

## 过程

### 1.客户端 $\rightarrow$ 服务器： DHCP 发现报文

- 携带信息：客户主机的 MAC 地址（还可以提出对 IP 地址租用期的要求）

- 网络层：**源 IP 地址 = 0.0.0.0 ，目的 IP 地址 = 255.255.255.255 （广播 IP 数据报）**
  链路层：源 MAC 地址 = 客户主机的 MAC 地址，目的 MAC 地址 = 全 1 **（广播帧）**

### 2.服务器 $\rightarrow$ 客户端： DHCP 提供报文

- 携带信息：给客户主机分配的 IP 地址、**租用期**、子网掩码、默认网关

- 网络层：**源 IP 地址 = DHCP 服务器的 IP 地址 ，目的 IP 地址 = 255.255.255.255 （广播 IP 数据报）**
  链路层：源 MAC 地址 = DHCP 服务器的 MAC 地址，目的 MAC 地址 = 客户主机的 MAC 地址 **（单播帧）**

### 3.客户端 $\rightarrow$ 服务器： DHCP 请求报文

- 携带信息：客户主机确认要使用的 IP 地址

- 网络层：**源 IP 地址 = 0.0.0.0 ，目的 IP 地址 = 255.255.255.255 （广播 IP 数据报）**
  链路层：源 MAC 地址 = 客户主机的 MAC 地址，目的 MAC 地址 = 全 1 **（广播帧）**

### 4.服务器 $\rightarrow$ 客户端： DHCP 确认报文

- 携带信息：与**提供报文**类似

- 网络层：**源 IP 地址 = DHCP 服务器的 IP 地址 ，目的 IP 地址 = 255.255.255.255 （广播 IP 数据报）**
  链路层：源 MAC 地址 = DHCP 服务器的 MAC 地址，目的 MAC 地址 = 客户主机的 MAC 地址 **（单播帧）**

```

DHCP （Dynamic Host Configuration Protocol）动态主机配置协议，常用于给主机动态分配 IP 地址、配置子网掩码、默认网关等网络相关参数

DHCP 是应用层协议，使用 UDP 协议进行通信

通常情况下，每个网络都会配置一台 DHCP 服务器

假设有以下网络拓扑：

![DHCP 工作流程](//store.s1r0ko.top/svg/m/cn/21/14_ver_2.svg)

考虑以下情况：

- **假设 H3 是刚接入网络的主机，分析 DHCP 动态配置 IP 的过程**

1. H3 的 DHCP 客户端进程封装 DHCP 发现报文（DHCP 发现报文的内容是 H3 的 MAC 地址），并且按照如下格式封装并发送给全部主机

![DHCP 发现报文](//store.s1r0ko.top/svg/m/cn/21/15_ver_2.svg)

对于非 DHCP 服务器收到该报文，在传输层会进行丢弃，因为没有进程运行在 67 端口上

2. DHCP 服务器收到 DHCP 发现报文后，会对发现报文中的内容进行解析，并且在自己管理的 IP 地址池中挑选一个暂时没有使用的 IP 地址，然后封装 DHCP 提供报文，并且按照如下格式封装并发送给 H3 

![DHCP 提供报文](//store.s1r0ko.top/svg/m/cn/21/16_ver_3.svg)

3. 发送经过交换机的精准转发后会直接到达 H3 其他节点不会收到这个报文， H3 接收提供报文并检查处理后会封装新的**请求报文**然后以广播帧的形式发出去

![DHCP 请求报文](//store.s1r0ko.top/svg/m/cn/21/17_ver_2.svg)

::: warning 关于为什么要四步获取 IP 地址，而不是在第二步就直接使用该 IP 地址

一个局域网内可能存在多个 DHCP 服务器，在新主机请求 IP 地址时，会向所有 DHCP 服务器发送 DHCP 发现报文，每个 DHCP 服务器都会回复 DHCP 提供报文，新主机确认自己选择的 IP 地址后会**广播** DHCP 请求报文，确保所有 DHCP 服务器知道新主机选择的 IP 地址

:::

4. DHCP 服务器收到请求报文后，确认 IP 地址没有冲突，就会封装 DHCP 确认报文，并且按照如下格式封装并发送给 H3 ，此时由于 H3 获取 IP 地址的流程还没有完成，仍然是没有 IP 地址，所有该报文仍是以广播形式发出

![DHCP 确认报文](//store.s1r0ko.top/svg/m/cn/21/18_ver_3.svg)

5. H3 收到确认报文后，会解析确认报文中的内容，并且将 IP 地址、子网掩码、默认网关配置到自己的网络接口上，完成 IP 信息的配置，如下图所示

![DHCP 最终配置](//store.s1r0ko.top/svg/m/cn/21/19_ver_1.svg)

## ICMP 

ICMP （Internet Control Message Protocol ）网际控制报文协议，用于在 IP 主机、路由器之间传递差错控制消息

```markmap
---
markmap:
  colorFreezeLevel: 4
  maxWidth: 750
---

# ICMP

## **ICMP 属于网络层， ICMP 报文封装在 IP 数据报中**。 ICMP 可以让主机或路由器互相报告网络中发生的差错和异常情况

## **ICMP 报文的常见类型**

### **差错报告报文**

- **终点不可达**

  - 路由器告诉发送方：“目的地址不可到达” （道路不通）

  - 目的主机告诉发送方：“目的端口号不存在，我这里没有对应进程”

- **时间超过**

  - 路由器告诉发送方：“你的数据报到我这里 TTL = 0 了，被我丢了” （路程太远）

  - 目的主机告诉发送方：“你到 IP 数据报被分片了，规定时间内没收齐，我已全部丢弃”

- **参数问题**

  - 告诉发送方：“你的 IP 数据报首部参数不合法、或首部校验出错”

- **改变路由（重定向）**

  - 路由器告诉发送方：“对于这个目的网络，下次你让另一台路由器帮你转发，路径会更短”

- ~~源点抑制~~（ 2012 年后废除）

  - 报告发送方：“网络发生拥塞，丢包了，求求你发慢点！”

### **询问报文**

- **回送请求（ Echo Request ）**

  - A $\rightarrow$ B : 在吗？

- **回送回答（ Echo Reply ）**

  - B $\rightarrow$ A : 在！

- **时间戳请求（ Timestamp Request ）**

  - A $\rightarrow$ B : 我这边时间是 xxxx ，你那边几点了？

- **时间戳回答（ Timestamp Reply ）**

  - B $\rightarrow$ A : 我收到请求的时间是 yyyy ，我回答的时间是 zzzz

## **不必反馈 ICMP 差错报告报文**的情况

### 若携带 ICMP 差错报告报文的 IP 数据报出错，不再反馈 ICMP 差错

### 若 IP 数据报被分片，则无论几个分片出错，都只反馈一次 ICMP 差错

### 若 IP 数据报的目的地址为多播地址，不反馈 ICMP 差错

### 若 IP 数据报的源地址为特殊地址（如： 127.x.x.x 、 0.0.0.0 等），则即便发生 IP 数据报异常也不反馈 ICMP 差错

## ICMP 的典型应用

### ping 基于**回送请求报文、回送回答报文**实现功能

### tracerouter （ tracert ）基于**时间超过报文**实现功能

```

### ICMP 报文结构

ICMP 报文在普通的 [IP 数据报](./IPv4.html#ip-数据报的格式)的数据部分有所不同

![ICMP 报文结构](//store.s1r0ko.top/svg/m/cn/21/20_ver_1.svg)

::: warning

这里需要注意的是， IP 数据报首部的协议字段为 1 ，表示 ICMP 协议

:::

### ICMP 差错报告报文

- **终点不可达**

  - IP 地址不存在

  本地主机发送了一个 IP 数据报，目的地址在目标局域网内并不存在，该数据报经目的局域网的路由器转发时，路由器发现该地址不存在，就会构造一个 ICMP 差错报告报文，通知发送方该地址不存在， ICMP 数据报类型为“终点不可达”， ICMP 数据报内容为该 IP 地址不可达，字段包含不可达 IP 地址

  - 端口不存在

  本地主机发送了一个 IP 数据报，目标主机存在，数据报可以到达目标主机，但是目的主机的传输层检查发现没有对应端口的进程，于是构造一个 ICMP 差错报告报文，通知发送方该端口不存在， ICMP 数据报类型为“终点不可达”， ICMP 数据报内容为不存在端口为 xxxx 的进程

- **时间超过**

  - TTL 为到达目的主机时已经为 0 

  本地主机发送数据报前设置的 TTL 较少，导致到达目的主机路由器前 TTL 就已经耗尽，于是在 TTL 刚好到 0 的路由器接收到该数据报，就会丢弃该数据报，并且构造一个 ICMP 差错报告报文，通知发送方该数据报的 TTL 已耗尽， ICMP 数据报类型为“时间超过”， ICMP 数据报内容为该数据报的 TTL 已耗尽

  - IP 数据报分片为按时全部抵达

  本地主机发送了一个 IP 数据报，数据报长度过长，超过了 MTU ，于是该数据报就会被分片，并分别转发出去，由于每个分片的路由路径可能不同，到达目的主机的时间也有所不同，最终在规定时间内，仍有部分分片未到达目的主机，于是构造 ICMP 数据报，类型为“时间超过”，内容为由于分片超时未收齐，已将全部已收到分片丢弃

- **参数问题**

IP 数据报在传输过程中，某台路由器检测到 IP 数据报的首部参数有问题，比如 IP 数据报的长度字段与实际数据长度不一致，或者 IP 数据报的校验和字段与计算结果不一致，就会丢弃该数据报，并且构造一个 ICMP 数据报，类型为“参数问题”，内容为 IP 数据报的首部参数有问题

- **改变路由（重定向）**

本地主机发送了一个 IP 数据报，通常这个数据报会发送给默认路由，但是该路由表中，该目的地址的下一跳路由不是最优路由，于是该路由器就会构造一个 ICMP 数据报，类型为“改变路由”，内容为该目的地址的下一跳路由不是最优路由，字段包含该目的地址和最优路由的下一跳 IP 地址，并且将该 ICMP 数据报发送给发送方，发送方收到该数据报后，就会更新路由表，将该目的地址的下一跳路由更新为最优路由，并且重新发送数据报

- **~~源点抑制~~**

当某个网络节点中的路由器检测到网络拥塞时，会随机丢弃其中的部分数据报，并向这些数据报的源主机发送 ICMP 数据报，类型为“源点抑制”

### ICMP 询问报文

- **回送请求、回送回答**

假设主机 A 需要探测去往主机 B 的网络通路是否通畅，则可以构造一个 ICMP 报文，类型为“回送请求”，通过网络层层转发后到达主机 B ，主机 B 收到该 ICMP 报文后，就会构造一个 ICMP 报文，类型为“回送回答”，并将该 ICMP 报文发送给主机 A ，主机 A 收到该 ICMP 报文后，就可以知道到达主机的通路 B 是畅通的

例如： ping 命令

- **时间戳请求、时间戳回答**

和回送请求、回答的过程类似，传递的信息有所不同，发送方在 ICMP 报文的时间戳字段中填写当前时间，接收方在 ICMP 报文的时间戳字段中填写接收时间和发送回复时间

例如： tracerouter （ tracert ）命令




  