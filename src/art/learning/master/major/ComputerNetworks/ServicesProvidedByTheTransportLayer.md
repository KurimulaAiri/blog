---
title: 传输层提供的服务
date: 2025-08-05
icon: 'earth-americas'
order: 24
category: 
    - '408'
    - '计算机网络'
    - 考研
---

## 传输层概述

```markmap
---
markmap:
  colorFreezeLevel: 4
  maxWidth: 400
---

# 传输层概述

## 端口的作用

### 通过“**端口号**”标识主机的一个特定进程

- 注意

    - 每台主机的端口号是互相的独立的

    - TCP 、 UDP 两种协议的端口号是相互独立的

### TCP 或 UDP 协议、通过 **Socket 套接字** = { IP 地址:端口号}，唯一地标识网络中的一台主机上的一个应用进程

### 端口号的分类

- 服务器使用的端口号

    - **熟知端口号 0~1023**

        - 通常只能用于被熟知的重要应用程序

    - 登记端口号 1024~49151 （现已不再严格遵守）

- 客户端使用的端口号

    - 短暂端口号 49152~65535 （现已不再严格遵守）

## 功能

### 实现端到端（进程到进程）的通信

### 复用和分用

- 复用（从上到下）：在发送数据的时候，同一台主机上的多个进程可以使用同一个传输层协议

- 分用（从下到上）：在接收数据的时候，传输层可以把数据正确交付到目的进程

### 差错检测

- TCP 检测出差错后**丢弃数据**，并通知发送方**重传**

- UDP 检测出差错后直接**丢弃数据**，且**不通知发送方**

### 向应用层提供两种服务

- 面向连接的、可靠的端到端传输服务（ TCP ）——确保数据正确、完整，但是开销大、实时性较差

- 无连接的、不可靠端到端传输服务（ UDP ）——数据可能出错、丢失，但速度快、开销小

```

两台主机的两个应用通过 `IP + 端口号`（套接字） 实现通信

套接字分为： TCP 套接字和 UDP 套接字

::: warning

- 两台主机的端口号是相互独立的

- TCP 、 UDP 的端口号也是相互独立的

- 当两个进程之间需要进行通信时，需要指明：

    1. 使用哪种传输层协议

    2. 本进程绑定的端口号

    3. 对方 IP 地址和端口号

:::

### 熟知端口号

0~1023 为熟知端口号，开发的时候一般不使用

其他端口号在实际开发时没有特别严格的限制，只要在本机没有被使用的端口号都可以使用

端口号分类只是一种“建议标准”，而非“强制标准”

::: tip 常见熟知端口号

| 应用程序 | FTP | TELNET | SMTP | DNS | TFTP | HTTP | SNMP |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 端口号 | 21 | 23 | 25 | 53 | 69 | 80 | 161 |

:::

### 有连接和无连接

有连接：在传输数据前先打招呼，先确认对方已经准备好接收数据。传输结束时也要告知对方已结束

无连接：不打招呼，直接把数据传给对方

### 可靠传输和不可靠传输

可靠传输：接收方使用“确认机制”让发送方知道哪些数据已经被正确接收

不可靠的：接收方无论收没收到数据、数据是否正确，都不给发送方反馈

## UDP 协议

### UDP 数据报

传输层收到应用层的数据后会在其首部添加一个 8 B 大小的 UDP 首部

UDP 数据报有以下特点

- UDP 首部很小只占 8 B

- UDP 每次传输一个完整的报文，不支持报文自动拆分、重装

- UDP 是无连接的、不可靠的（可靠性可以交给应用层处理），也不支持拥塞控制

- UDP 支持一对一（封装成单播 IP 数据报）、一对多传输（封装成广播 / 多播 IP 数据报）

![UDP 数据报格式](//store.s1r0ko.top/svg/m/cn/24/1_ver_1.svg)

::: warning

- 由于 UDP 不支持报文拆分和重装，因此应用层的报文长度不能超过 UDP 协议上限

UDP 数据报中，首部固定占 8 B

首部各字段及其作用：

| 字段名 | 作用 |
| :---: | :---: |
| 源端口号 | 发送进程的端口号（如果不需要对方回复可以全设置为 0 ） |
| 目的端口号 | 接收进程的端口号（必填） |
| UDP 长度 | 包含首部，以“字节”为单位 |
| UDP 检验和 | 由发送方的传输计算并填入校验和，接收方的传输层检测是否有差错（如果无需校验，可以填入全 0 ） |

数据部分为一个完整的应用层报文

UDP 数据报理论最大长度为 **65535 B** （ 64 Kb ）这是由 **IP 数据报数据部分长度限制**（ IP 数据报数据部分最长为 65535 B ）所限制的

:::

### UDP 检验

![UDP 检验过程格式](//store.s1r0ko.top/svg/m/cn/24/2_ver_2.svg)

对于**发送方**{#blue-msg}，会在交付给网络层之前进行**检验和计算**，并将结果填入 UDP 首部的检验和字段中，具体步骤如下

1. 传输层 UDP 协议在计算检验和之前，先添加一个伪首部

2. 把伪首部、首部、数据部分以 16 bit 为一组，进行[二进制加法](text.com)（最高位产生的进位需要回卷）

3. 将最终的加法结果逐位取反，就得到 16 bit 的检验和，将其填入 UDP 首部

4. 去掉伪首部，并将 UDP 数据报交给网络层，封装成 IP 数据报

对于**接收方**{#blue-msg}收到数据后也会有相似的操作

1. 网络层向传输层递交 UDP 数据报

2. 传输层在 UDP 数据报之前，添加伪首部

3. 吧伪首部、 UDP 首部、数据部分以 16 bit 为一组，进行[二进制加法](./test.html)（最高位的进位需要回卷）

4. 如果加法结果全为 1 ，说明没有比特错误，于是接收该 UDP 数据报，并根据目的端口号，向应用层递交报文；如果加法结果不全为 1 ，说明有差错，于是丢弃该 UDP 数据报

- **二进制计算过程**

假设有 48 bit 数据为：

$$

0101\ 0000\ 0110\ 0101 \\
0110\ 1001\ 0101\ 0001 \\
0110\ 0101\ 1100\ 0101 \\

$$

计算过程为：

$$

\begin{array}{cc}

& \ \ \ \ 0101 \ 0000 \ 0110 \ 0101  \\

& \underline{+ \ 0110 \ 1001 \ 0101 \ 0001}  \\

& \ \ \ \ 1011 \ 1001 \ 1011 \ 0110 \\

& \underline{+ \ 0110 \ 0101 \ 1100 \ 0101} \\

& \ \ \ \ 0001 \ 1111 \ 0111 \ 1011 \\

& \text{回卷得到：} \\

& \ \ \ \ 0001 \ 1111 \ 0111 \ 1100 \\

& \text{取反得到：} \\

& \ \ \ \ 1110 \ 0000 \ 1000 \ 0011 \\

\end{array}

$$

得到检验和为：**1110 0000 1000 0011**{#red-msg}

::: warning

对于伪首部中的字段

| 字段名 | 含义 |
| :---: | :---: |
| 源 IP 地址 | 发送方的 IP 地址 |
| 目的 IP 地址 | 接收方的 IP 地址 |
| 全零 | 占 1 B，全 0 ，用于填充 |
| 协议 | 传输层协议（ UDP 为 17 ） |
| 数据长度 | UDP 数据报的长度（和首部中的 UDP 长度字段相同） |

对于为什么在过程中需要添加伪首部不需要详细讨论

:::

## TCP 协议

TCP 的传输单元称为 **TCP 报文段 / TCP 段** 因 TCP 协议可对应用层报文进行拆分传输而得名

TCP 传输过程中分为三个步骤，这三个步骤中传输的数据单元均为 TCP 段

1. 建立连接（三次握手）

2. 数据传输

3. 释放连接（四次挥手）

![TCP 传输过程](//store.s1r0ko.top/svg/m/cn/24/3_ver_2.svg)

在上图中， 3 次握手对应发送三个 TCP 报文段

握手后建立 TCP 连接可以进行全双工通信

挥手 ① 和挥手 ② 表示进程 A 已经没有需要发送的数据了，两次挥手后单向断开连接

之后只有进程 B 可以向进程 A 发送数据，反之则不行

挥手 ③ 和挥手 ④ 表示进程 B 也没有需要发送的数据了，这两次挥手后关闭进程 B 到进程 A 的连接

最后结束通信

::: warning 

- 建立一次 TCP 连接可以传输多个应用层报文（可双向）

- TCP 是面向字节流的（而 UDP 是面向报文的），无论传输多少应用层报文，在 TCP 看来就是一大串字节流即字节流是无边界的，一个 TCP 报文段可以包含多个应用层报文的分段

- 挥手结束 TCP 连接时可以由服务器发起第一次挥手也可以由客户端发起

- TCP 报文段数据部分的大小受限于 MSS （Max Segment Size），MSS 是 TCP 连接双方协商的最大报文段数据部分大小（有效大小），MSS 的值在 TCP 连接建立时协商，并且 TCP 段**不会强制要求**数据部分大小一定要填充至 MSS 只需要保证不超过即可

:::

### TCP 数据报

TCP 数据报有以下特点：

- TCP 首部更大，占 20 B ~ 60 B

- TCP 支持报文自动拆分、重装，因此可以传输长报文

- TCP 是有连接的、可靠的、支持拥塞控制

- TCP 仅支持一对一传输（因为通信双方的传输层必须先建立连接）

TCP 支持报文拆分和重装，所以可以进行长报文的传输

**对于 TCP 段的首部字段，不需要记住各字段的顺序和位置，只需要记住每个字段的含义即可**{#red-msg}

![TCP 数据段结构](//store.s1r0ko.top/svg/m/cn/24/4_ver_3.svg)

::: info TCP 数据段首部各字段及其含义（标红为重点）

| 字段名 | bit 数 | 含义 | 备注 |
| :---: | :---: | :---: | :---: |
| **源端口**{#red-msg} | 16 bit | 发送进程的端口号 |
| **目的端口**{#red-msg} | 16 bit | 接收进程的端口号 |
| **序号**{#red-msg} | 32 bit | 用于标记数据部分第一个字节在原始字节流中的位置 | 用于接收方重组应用层数据报，起始“序号”是由发送方自己设置的，**不一定从 0 开始**{#blue-msg}，通常简写为 seq |
| **确认号**{#red-msg} | 32 bit | 用于反馈，表示序号在该确认号（某字节位）之前的所有字节都已正确接收 | 通常记为 ack 或 ack_seq |
| 数据偏移 | 4 bit | 数据偏移量，单位为 4 B，指出 TCP 数据段的首部长度 | 取值范围为 0 ~ 15 |
| 保留 | 6 bit | 占 6 bit，全 0 ，目前暂时没有用 |
| URG | 1 bit | 紧急指针有效位，为 1 时表示该 TCP 数据段为紧急数据，应尽快推送 | 不常考 |
| **ACK**{#red-msg} | 1 bit | 确认号有效位，为 0 时， ack_seq 无效；为 1 时， ack_seq 有效 | 通常记为 ACK ，**除握手 ① 之外，其他所有 TCP 段的 ACK 都为 1**{#blue-msg} |
| PSH | 1 bit | 推送位，为 1 时表示发送方希望接收方尽快回复（用于交互式通信） | 不常考 |
| RST | 1 bit | 重置连接位，为 1 时表示出现严重差错（如主机崩溃），必须释放连接；同时也可以用于拒绝一个非法报文段（如黑客恶意共计） | 当有一方接收到非法报文段时，会发送一个 RST 为 1 的报文段，示意双方尽快释放连接避免进一步的安全隐患；不常考 |
| **SYN**{#red-msg} | 1 bit | 同步序号位，为 1 时表示这是一个请求连接或者接收连接的报文 | **只有握手 ① 和握手 ② 的 SYN 值为 1 其他都为 0**{#blue-msg} |
| **FIN**{#red-msg} | 1 bit | 结束位，为 1 时表示发送方没有更多数据要发送了，数据已经发送完毕，要求释放连接 | **只有挥手 ① 和挥手 ③ 的 FIN 值为 1 其他都为 0**{#blue-msg} |
| **窗口**{#red-msg} | 16 bit | 用于流量控制的关键，表示接收窗口的大小。即从本报文段首部中的 ack_seq 算起，接收方还能接收多少数据（以字节为单位），即接收方接收缓冲区的剩余空间大小 | 一般简写为 rwnd 或 rcvwnd |
| 校验和 | 16 bit | 用于校验 TCP 数据段首部和数据部分，和 UDP 校验和的计算雷同，也需要添加伪首部再进行计算，只是需要把协议字段的 17 改成 6 （TCP 协议号）、 UDP 长度字段改为 TCP 的长度 | 不常考 |
| 紧急指针 | 16 bit | 紧急数据的专用序号，原理和上面的序号类似，所填的值为当前 TCP 数据段的紧急数据末尾字节的下一字节的偏移量，例如：数据部分长度为 8 字节，紧急数据长度为 4 字节，那么紧急指针就填写 4 （即 0 ~ 3 字节为紧急数据，紧急数据末尾字节的下一字节偏移量为 4 也就是第 4 字节开始都是普通数据，之前的都是紧急数据） | **TCP 数据段如同时含有普通数据和紧急数据，紧急数据必须位于普通数据之前**{#blue-msg}，不常考 |
| 选项 | 不定长 | 建立 TCP 连接时，在握手 ① 和握手 ② 中在选项这里协商 MSS ，一般指发送该 TCP 段的来源方的 MSS ，向对方通知自己发送的数据的大小限制 | 一般就考 MSS 在这部分协商 |
| 填充 | 不定长 | 用于将 TCP 段首部填充至 4 B 的整数倍大小 | |

- TCP 报文段首部没有专门的字段指明 TCP 段的长度为多少（会根据 IP 首部、 TCP 首部的信息算出来）

- 对于标志位为 1 的 TCP 段可以称为对应的标志名 + 段，例如： SYN = 1 时，对应 TCP 段可称为 SYN 段，对于含多个等于 1 的标志位的 TCP 段可以称所有的标志名 + 段，例如：一个 SYN = 1 且 ACK = 1 的 TCP 段可以称其为 SYN 段，也可以称其为 ACK 段

- 现实应用中通常 MSS 不会设置得太大，避免 IP 数据报分片

:::

### TCP 连接管理

要点：建立连接，数据传输，释放连接过程中， TCP 报文段中 SYN 、 ACK 、 seq 、 ack 等关键字段的变化和区别，以及双方 TCP 状态的变化等

::: info 建立连接

![TCP 建立连接字段变化](//store.s1r0ko.top/svg/m/cn/24/5_ver_2.svg)

握手 ③ 后进入 TCP 双工传输阶段，根据握手 ③ 是否携带数据，服务器发出的第一个 TCP 数据段字段也有所不同

这里假设携带 100 B 数据

| 第一个 TCP 数据段的字段 | 握手 ③ 携带数据 | 握手 ③ 不携带数据 |
| :---: | :---: | :---: |
| SYN | 0 | 0 |
| ACK | 1 | 1 |
| FIN | 0 | 0 |
| seq | 51 | 51 |
| ack | 767 | 667 |

- TCP 全过程中，只有握手 ① 和握手 ② 中 SYN 为 1 ，其他都为 0

- 握手 ① 和握手 ② 不能携带数据（只有 TCP 首部），但是仍要消耗一个序号

- 握手 ③ 可以携带数据，也可以不携带数据，如果不携带数据，就可以不消耗序号

:::





