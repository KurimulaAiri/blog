---
title: 传输层提供的服务
date: 2025-08-04
icon: 'earth-americas'
order: 24
category: 
    - '408'
    - '计算机网络'
    - 考研
---

## 传输层概述

```markmap
---
markmap:
  colorFreezeLevel: 4
  maxWidth: 400
---

# 传输层概述

## 端口的作用

### 通过“**端口号**”标识主机的一个特定进程

- 注意

    - 每台主机的端口号是互相的独立的

    - TCP 、 UDP 两种协议的端口号是相互独立的

### TCP 或 UDP 协议、通过 **Socket 套接字** = { IP 地址:端口号}，唯一地标识网络中的一台主机上的一个应用进程

### 端口号的分类

- 服务器使用的端口号

    - **熟知端口号 0~1023**

        - 通常只能用于被熟知的重要应用程序

    - 登记端口号 1024~49151 （现已不再严格遵守）

- 客户端使用的端口号

    - 短暂端口号 49152~65535 （现已不再严格遵守）

## 功能

### 实现端到端（进程到进程）的通信

### 复用和分用

- 复用（从上到下）：在发送数据的时候，同一台主机上的多个进程可以使用同一个传输层协议

- 分用（从下到上）：在接收数据的时候，传输层可以把数据正确交付到目的进程

### 差错检测

- TCP 检测出差错后**丢弃数据**，并通知发送方**重传**

- UDP 检测出差错后直接**丢弃数据**，且**不通知发送方**

### 向应用层提供两种服务

- 面向连接的、可靠的端到端传输服务（ TCP ）——确保数据正确、完整，但是开销大、实时性较差

- 无连接的、不可靠端到端传输服务（ UDP ）——数据可能出错、丢失，但速度快、开销小

```

两台主机的两个应用通过 `IP + 端口号`（套接字） 实现通信

套接字分为： TCP 套接字和 UDP 套接字

::: warning

- 两台主机的端口号是相互独立的

- TCP 、 UDP 的端口号也是相互独立的

- 当两个进程之间需要进行通信时，需要指明：

    1. 使用哪种传输层协议

    2. 本进程绑定的端口号

    3. 对方 IP 地址和端口号

:::

### 熟知端口号

0~1023 为熟知端口号，开发的时候一般不使用

其他端口号在实际开发时没有特别严格的限制，只要在本机没有被使用的端口号都可以使用

端口号分类只是一种“建议标准”，而非“强制标准”

::: tip 常见熟知端口号

| 应用程序 | FTP | TELNET | SMTP | DNS | TFTP | HTTP | SNMP |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 端口号 | 21 | 23 | 25 | 53 | 69 | 80 | 161 |

:::

### 有连接和无连接

有连接：在传输数据前先打招呼，先确认对方已经准备好接收数据。传输结束时也要告知对方已结束

无连接：不打招呼，直接把数据传给对方

### 可靠传输和不可靠传输

可靠传输：接收方使用“确认机制”让发送方知道哪些数据已经被正确接收

不可靠的：接收方无论收没收到数据、数据是否正确，都不给发送方反馈

## UDP 协议

### UDP 数据报

传输层收到应用层的数据后会在其首部添加一个 8 B 大小的 UDP 首部

UDP 数据报有以下特点

- UDP 首部很小只占 8 B

- UDP 每次传输一个完整的报文，不支持报文自动拆分、重装

- UDP 是无连接的、不可靠的（可靠性可以交给应用层处理），也不支持拥塞控制

- UDP 支持一对一（封装成单播 IP 数据报）、一对多传输（封装成广播 / 多播 IP 数据报）

![UDP 数据报格式](//store.s1r0ko.top/svg/m/cn/24/1_ver_1.svg)

::: warning

- 由于 UDP 不支持报文拆分和重装，因此应用层的报文长度不能超过 UDP 协议上限

UDP 数据报中，首部固定占 8 B

首部各字段及其作用：

| 字段名 | 作用 |
| :---: | :---: |
| 源端口号 | 发送进程的端口号（如果不需要对方回复可以全设置为 0 ） |
| 目的端口号 | 接收进程的端口号（必填） |
| UDP 长度 | 包含首部，以“字节”为单位 |
| UDP 检验和 | 由发送方的传输计算并填入校验和，接收方的传输层检测是否有差错（如果无需校验，可以填入全 0 ） |

数据部分为一个完整的应用层报文

UDP 数据报理论最大长度为 **65535 B** （ 64 Kb ）这是由 **IP 数据报数据部分长度限制**（ IP 数据报数据部分最长为 65535 B ）所限制的

:::

### UDP 检验

![UDP 检验过程格式](//store.s1r0ko.top/svg/m/cn/24/2_ver_1.svg)

对于**发送方**{#blue-msg}，会在交付给网络层之前进行**检验和计算**，并将结果填入 UDP 首部的检验和字段中，具体步骤如下

1. 传输层 UDP 协议在计算检验和之前，先添加一个伪首部

2. 把伪首部、首部、数据部分以 16 bit 为一组，进行[二进制加法](text.com)（最高位产生的进位需要回卷）

3. 将最终的加法结果逐位取反，就得到 16 bit 的检验和，将其填入 UDP 首部

4. 去掉伪首部，并将 UDP 数据报交给网络层，封装成 IP 数据报

对于**接收方**{#blue-msg}收到数据后也会有相似的操作

1. 网络层向传输层递交 UDP 数据报

2. 传输层在 UDP 数据报之前，添加伪首部

3. 吧伪首部、 UDP 首部、数据部分以 16 bit 为一组，进行[二进制加法](./test.html)（最高位的进位需要回卷）

4. 如果加法结果全为 1 ，说明没有比特错误，于是接收该 UDP 数据报，并根据目的端口号，向应用层递交报文；如果加法结果不全为 1 ，说明有差错，于是丢弃该 UDP 数据报

- **二进制计算过程**

假设有 48 bit 数据为：

$$

0101\ 0000\ 0110\ 0101 \\
0110\ 1001\ 0101\ 0001 \\
0110\ 0101\ 1100\ 0101 \\

$$

计算过程为：

$$

\begin{array}{cc}

& \ \ \ \ 0101 \ 0000 \ 0110 \ 0101  \\

& \underline{+ \ 0110 \ 1001 \ 0101 \ 0001}  \\

& \ \ \ \ 1011 \ 1001 \ 1011 \ 0110 \\

& \underline{+ \ 0110 \ 0101 \ 1100 \ 0101} \\

& \ \ \ \ 0001 \ 1111 \ 0111 \ 1011 \\

& \text{回卷得到：} \\

& \ \ \ \ 0001 \ 1111 \ 0111 \ 1100 \\

& \text{取反得到：} \\

& \ \ \ \ 1110 \ 0000 \ 1000 \ 0011 \\

\end{array}

$$

得到检验和为：**1110 0000 1000 0011**{#red-msg}

::: warning

对于伪首部中的字段

| 字段名 | 含义 |
| :---: | :---: |
| 源 IP 地址 | 发送方的 IP 地址 |
| 目的 IP 地址 | 接收方的 IP 地址 |
| 全零 | 占 1 B，全 0 ，用于填充 |
| 协议 | 传输层协议（ UDP 为 17 ） |
| 数据长度 | UDP 数据报的长度（和首部中的 UDP 长度字段相同） |

对于为什么在过程中需要添加伪首部不需要详细讨论

:::

## TCP 协议

TCP 的传输单元称为 **TCP 报文段 / TCP 段** 因 TCP 协议可对应用层报文进行拆分传输而得名

TCP 传输过程中分为三个步骤，这三个步骤中传输的数据单元均为 TCP 段

1. 建立连接（三次握手）

2. 数据传输

3. 释放连接（四次挥手）

![TCP 传输过程](//store.s1r0ko.top/svg/m/cn/24/3_ver_2.svg)

### TCP 数据报

TCP 数据报有以下特点：

- TCP 首部更大，占 20B~60B

- TCP 支持报文自动拆分、重装，因此可以传输长报文

- TCP 是有连接的、可靠的、支持拥塞控制

- TCP 仅支持一对一传输（因为通信双方的传输层必须先建立连接）

TCP 支持报文拆分和重装，所以可以进行长报文的传输


