---
title: 操作系统的运行机制
date: 2025-08-15
icon: 'gears'
order: 4
category: 
    - '408'
    - '操作系统'
    - 考研  
---

## 程序是如何运行的？

一条高级语言的代码翻译过来可能会对应多条机器指令（二进制）

一般来说高级语言通过编译，翻译成汇编语言，再通过汇编语言翻译成机器指令

程序运行的过程其实就是 CPU 执行一条一条的机器指令的过程

“指令”就是处理器（ CPU ）能识别、执行的最基本命令，而不是命令行中输入的命令

## 内核程序和应用程序

普通程序员编写的程序叫做**应用程序**，他是运行在操作系统之上的

编写操作系统的程序员编写的程序叫做**内核程序**，由大量内核程序组成了“**操作系统内核**”，简称为“**内核**”

**内核**是操作系统最重要最核心的部分，也是**最接近硬件的部分**

操作系统只需要有内核即可正常运行，但操作系统的部分功能未包含在内核中，比如图形化用户界面 GUI 

## 特权指令和非特权指令

操作系统内核作为“管理者”有时会让 CPU 执行一些“特权指令”，如：内存清零指令。这些指令影响重大，只允许“管理者”——即操作系统内核来使用

应用程序只能使用“非特权指令”，如：加法指令、减法指令等

**在 CPU 设计和生产的时候就划分了特权指令和非特权指令**，因此 CPU 执行一条指令前就能判断出其类型

## 内核态和用户态

为了使 CPU 能够区分正在运行的指令属于应用程序还是内核程序，CPU 设计了两种不同的工作状态：**内核态**和**用户态**

CPU 中有一个寄存器叫程序状态字寄存器，简称 PSW ，其中有一个二进制位，其处于 **1** 时表示**内核态**；处于 **0** 时表示**用户态**，不同 CPU 可能表示的位数和二进制数有所不同

当 CPU 处于**内核态**时，说明此时运行的是**内核程序**，CPU 可以执行所有指令，包括**特权指令和非特权指令**

当 CPU 处于**用户态**时，说明此时运行的是**应用程序**，CPU 只能执行**非特权指令**

这两种状态还有别名：内核态（**管态**）和用户态（**目态**）

### 两种状态的切换 :thumbsup:

- **假设从开机开始的过程：**

1. 刚开机时， CPU 为“内核态”，操作系统内核程序先上 CPU 运行

2. 开机完成后，用户可以启动某个应用程序

3. 操作系统内核程序在合适的时候主动让出 CPU ，让该应用程序上 CPU 运行

:::tip 切换

操作系统内核在让出 CPU 之前，会用一条特权指令把 PSW 的标志位设置为“用户态”

:::

4. 应用程序运行在“用户态”

5. 此时如果向 CPU 输入一条特权指令

6. CPU 发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态”

7. 这个非法事件会引发一个**中断信号**

8. CPU **检测到中断信号后**，会立即**变为“核心态”**，并停止运行当前的应用程序，转而运行处理中断信号的内核程序

9. “中断”使操作系统再次夺回 CPU 的控制权

10. 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序

**内核态→用户态**：执行一条**特权指令**——**修改PSW的标志位为“用户态”**，这个动作意味着操作系统将主动让出 CPU 使用权

**用户态→内核态**：由“**中断**”引发，**硬件自动完成变态过程**，触发中断信号意味着操作系统将强行夺回 CPU 的使用权

::: tip [**中断**](./InterruptionsAndExceptions.html)

除了非法使用特权指令之外、还有很多事件会触发中断信号。一个共性是，**但凡需要操作系统介入的地方，都会触发中断信号**

:::
