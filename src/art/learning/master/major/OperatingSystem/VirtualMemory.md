---
title: 虚拟内存
date: 2025-11-20
icon: 'gears'
order: 19
category:
  - '408'
  - '操作系统'
  - 考研
---

- 传统存储管理方式（连续分配和非连续分配）的特征、缺点：

  - 一次性

  **作业必须一次性全部装入内存后才能开始运行**{#red-msg}。这会造成两个问题：

  ① 作业很大时，不能全部装入内存，导致大作业无法运行
  ② 当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致**多道程序并发度下降**{#red-msg}

  - 驻留性

  一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源

## 虚拟内存

虚拟内存采用了[局部性原理](/art/learning/master/major/OperatingSystem/Memory.html#具有快表的地址变换机构)

### 虚拟内存的定义和特征

基于局部性原理，在程序装入时，可以将程序中**很快会用到的部分装入内存，暂时用不到的部分留在外存**{#red-msg}就可以让程序开始执行
在程序执行过程中，当所访问的**信息不在内存时**{#red-msg}，由**操作系统负责将所需信息从外存调入内存**{#red-msg}，然后继续执行程序
若内存空间不够，由**操作系统负责将内存中暂时用不到的信息换出到外存**{#red-msg}
在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是**虚拟内存**{#red-msg}

::: tip

这也是操作系统虚拟性的一个体现，实际的物理内存大小没有变，只是在逻辑上进行了扩充

:::

### 虚拟内存的特征

- 多次性

无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存

- 对换性

在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出

- 虚拟性

从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量

### 如何实现虚拟内存

虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现
因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上

虚拟内存与传统非连续分配方式的主要区别在于：

在程序执行过程中，当所**访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存**{#red-msg}，然后继续执行程序（操作系统要提供**请求调页（或请求调段）功能**{#red-msg}）

若**内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存**{#red-msg}（操作系统要提供**页面置换（或段置换）的功能**{#red-msg}）

## 请求分页管理方式

相比于基本分页管理的页表，请求分页存储管理的页表字段有所不同

- 基本分页存储管理页表

| 页号 | 内存块号 |
| ---- | -------- |
| 0    | a        |
| 1    | b        |
| 2    | c        |

- 请求分页存储管理页表

| 页号 | 内存块号 | 状态位 | 访问字段 | 修改位 | 外存地址 |
| ---- | -------- | ------ | -------- | ------ | -------- |
| 0    | 无       | 0      | 0        | 0      | x        |
| 1    | b        | 1      | 10       | 0      | y        |
| 2    | c        | 1      | 6        | 1      | z        |

::: tip 各字段代表含义

- 状态位

表示该页是否已调入内存

0：表示该页不在内存中
1：表示该页已调入内存

- 访问字段

记录该页最近被访问的时间或最近被访问的次数，供页面置换算法参考

- 修改位

表示该页是否已被修改

0：表示该页未被修改
1：表示该页已被修改

- 外存地址

记录该页在外存中的地址

:::

### 缺页中断机构

在请求分页系统中，每当要访问的**页面不在内存**{#red-msg}时，便产生一个**缺页中断**{#red-msg}，然后由操作系统的缺页**中断处理程序处理中断**{#red-msg}

此时**缺页的进程阻塞**{#red-msg}，放入阻塞队列，调页**完成后再将其唤醒**{#red-msg}，放回就绪队列

如果内存中**有空闲块**{#red-msg}，则为进程**分配一个空闲块**{#red-msg}，将所缺页面装入该块，并修改页表中相应的页表项

**缺页中断**{#red-msg}是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此[**属于内中断**{#blue-msg}](/art/learning/master/major/OperatingSystem/InterruptionsAndExceptions.html#异常的分类)

**一条指令**{#red-msg}在执行期间，**可能产生多次缺页中断**{#red-msg}。（如： copy A to B ，即将逻辑地址 A 中的数据复制到逻辑地址 B ，而 A 、 B 属于不同的页面，则有可能产生两次中断）

### 地址变换机构

请求分页管理地址转换如图所示：

![请求分页管理地址转换](https://store.kurimula-airi.top/svg/m/os/19/1_ver_1.svg)

::: warning

快表中有的页面一定是在内存中的。若某个页面被换出外存,则快表中的相应表项也要删除否则可能访问错误的页面

找到对应页表项后，若对应页面未调入内存，则产生缺页中断，之后由操作系统的缺页中断处理程序进行处理

补充细节：

1. 只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数

2. 和普通的中断处理一样，缺页中断处理依然需要保留 CPU 现场

3. 需要用某种“页面置换算法”来决定一个换出页面

4. 换入/换出页面都需要启动慢速的 I/O 操作，可见，如果换入换出太频繁，会有很大的开销

5. 页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中

:::

## 页面置换算法

页面的换入、换出需要磁盘 I/O 操作，会有较大的开销，因此好的页面置换算法应该**追求更少的缺页率**{#red-msg}

### 最佳置换算法（ Optimal ）

每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率

:::: tip 例子

假设系统为某进程分配了三个内存块，并考虑到有一下页面号引用串（会依次访问这些页面）：

7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1

| 访问页面 | 7               | 0               | 1               | 2               | 0   | 3               | 0   | 4               | 2   | 3   | 0               | 3   | 2   | 1               | 2   | 0   | 1   | 7               | 0   | 1   |
| :------: | --------------- | --------------- | --------------- | --------------- | --- | --------------- | --- | --------------- | --- | --- | --------------- | --- | --- | --------------- | --- | --- | --- | --------------- | --- | --- |
| 内存块 1 | **7**{#red-msg} | 7               | 7               | **2**{#red-msg} | -   | 2               | -   | 2               | -   | -   | 2               | -   | -   | 2               | -   | -   | -   | **7**{#red-msg} | -   | -   |
| 内存块 2 | null            | **0**{#red-msg} | 0               | 0               | -   | 0               | -   | **4**{#red-msg} | -   | -   | **0**{#red-msg} | -   | -   | 0               | -   | -   | -   | 0               | -   | -   |
| 内存块 3 | null            | null            | **1**{#red-msg} | 1               | -   | **3**{#red-msg} | -   | 3               | -   | -   | 3               | -   | -   | **1**{#red-msg} | -   | -   | -   | 1               | -   | -   |
| 是否缺页 | Yes             | Yes             | Yes             | Yes             | No  | Yes             | No  | Yes             | No  | No  | Yes             | No  | No  | Yes             | No  | No  | No  | Yes             | No  | No  |

- 时间从左到右依次

在第一次调用页面 2 时，由于页表内没有该页面，因此产生缺页中断，需要将页面 2 调入内存

此时选择从 0，1，7 中淘汰页。按最佳置换的规则，往后寻找，**最后一个出现的页号就是要淘汰的页面**{#red-msg}

整个过程缺页中断发生了 9 次，页面置换发生了 6 次

**缺页时未必发生页面置换。若还有可用的空闲内存块就不用进行页面置换**{#red-msg}

缺页率 = 缺页次数 / 总访问次数 = 9 / 20 = 0.45

::: warning

最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的

:::

::::

### 先进先出置换算法（ FIFO ）

每次选择淘汰的页面是最早进入内存的页面

- 实现方法

把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可队列的最大长度取决于系统为进程分配了多少个内存块

::: tip 例子

假设系统为某进程分配了三个内存块，并考虑到有以下页面号引用串：

3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4

| 访问页面 | 3               | 2               | 1               | 0               | 3               | 2               | 4               | 3   | 2   | 1               | 0               | 4   |
| -------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- | --- | --- | --------------- | --------------- | --- |
| 内存块 1 | **3**{#red-msg} | 3               | 3               | **0**{#red-msg} | 0               | 0               | **4**{#red-msg} | -   | -   | 4               | 4               | -   |
| 内存块 2 | null            | **2**{#red-msg} | 2               | 2               | **3**{#red-msg} | 3               | 3               | -   | -   | **1**{#red-msg} | 1               | -   |
| 内存块 3 | null            | null            | **1**{#red-msg} | 1               | 1               | **2**{#red-msg} | 2               | -   | -   | 2               | **0**{#red-msg} | -   |
| 是否缺页 | Yes             | Yes             | Yes             | Yes             | Yes             | Yes             | Yes             | No  | No  | Yes             | Yes             | No  |

缺页次数 = 9

考虑一种情况，当可用内存块为 4 时，此时该算法的缺页次数为 10

这种现象被称为 **Belady 异常**{#red-msg} ——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象

只有 FIFO 算法会产生 Belady 异常。另外，FIFO 算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差

:::

### 最近最久未使用置换算法（ LRU ）

每次淘汰的页面是最近最久未使用的页面

- 实现方法

赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间 t。当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面

::: tip 例子

假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串：

1, 8, 1, 7, 8, 2, 7, 2, 1, 8, 3, 8, 2, 1, 3, 1, 7, 1, 3, 7

| 访问页面 | 1               | 8               | 1   | 7               | 8   | 2               | 7   | 2   | 1   | 8   | 3               | 8   | 2   | 1   | 3   | 1   | 7               | 1   | 3   | 7   |
| -------- | --------------- | --------------- | --- | --------------- | --- | --------------- | --- | --- | --- | --- | --------------- | --- | --- | --- | --- | --- | --------------- | --- | --- | --- |
| 内存块 1 | **1**{#red-msg} | 1               | -   | 1               | -   | 1               | -   | -   | -   | -   | 1               | -   | -   | -   | -   | -   | 1               | -   | -   | -   |
| 内存块 2 | null            | **8**{#red-msg} | -   | 8               | -   | 8               | -   | -   | -   | -   | 8               | -   | -   | -   | -   | -   | **7**{#red-msg} | -   | -   | -   |
| 内存块 3 | null            | null            | -   | **7**{#red-msg} | -   | 7               | -   | -   | -   | -   | **3**{#red-msg} | -   | -   | -   | -   | -   | 3               | -   | -   | -   |
| 内存块 4 | null            | null            | -   | null            | -   | **2**{#red-msg} | -   | -   | -   | -   | 2               | -   | -   | -   | -   | -   | 2               | -   | -   | -   |
| 是否缺页 | Yes             | Yes             | No  | Yes             | No  | Yes             | No  | No  | No  | No  | Yes             | No  | Yes | No  | No  | No  | Yes             | No  | No  | Yes |

在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面

该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大

:::

### 时钟置换算法（ Clock ）

最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近 OPT 算法性能的，但是实现起来需要专门的硬件支持，算法开销大

时钟置换算法是一种性能和开销较均衡的算法，又称 CLOCK 算法，或最近未用算法（ NRU，NotRecently Used ）

- 简单的 CLOCK 算法实现方法

为每个页面设置一个访问位，再将内存中的页面都通过链接指针**链接成一个循环队列**{#red-msg}。当某页被访问时，其访问位置为 1 。当需要淘汰一个页面时，只需检查页的访问位。如果是 0 ，就选择该页换出：如果是 1 ，则将它置为 0 ，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是 1 ，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描（第二轮扫描中一定会有访问位为 0 的页面，因此简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描）

::: tip

访问位为 1 ，表示最近访问过

访问位为 0 ，表示最近没访问过

:::

::: tip 例子 （ AI 生成）

要理解**时钟置换算法**，我们可以通过一个具体例子来逐步分析其执行过程。

- 时钟置换算法的核心逻辑
  它为每个内存页帧维护一个**访问位（use bit）**，所有页帧在内存中形成一个**环形队列**。当需要替换页时，从当前指针位置开始扫描：

  - 若遇到**访问位为 0** 的页，直接替换它；
  - 若遇到**访问位为 1** 的页，将其访问位重置为 0，继续扫描；
  - 直到找到第一个访问位为 0 的页，完成替换后，指针移动到该页的下一个位置。

- 例子：内存块数=3，访问序列=「7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1」

我们假设初始时内存为空，3 个内存块的访问位均为 0，指针初始位置指向“内存块 1”。

| 步骤 | 访问页面 | 内存块 1（访问位） | 内存块 2（访问位） | 内存块 3（访问位） | 指针位置 | 替换过程 & 访问位变化                                             | 缺页？ |
| ---- | -------- | ------------------ | ------------------ | ------------------ | -------- | ----------------------------------------------------------------- | ------ |
| 1    | 7        | 7（1）             | -                  | -                  | 块 1     | 装入 7，访问位置 1                                                | 是     |
| 2    | 0        | 7（0）             | 0（1）             | -                  | 块 2     | 装入 0，访问位置 1；7 的访问位重置为 0                            | 是     |
| 3    | 1        | 7（0）             | 0（0）             | 1（1）             | 块 3     | 装入 1，访问位置 1；0 的访问位重置为 0                            | 是     |
| 4    | 2        | 7（0）             | 0（0）             | 1（0）             | 块 1     | 扫描：<br>块 1（7，访问位 0）→ 替换为 2，访问位置 1；指针移到块 2 | 是     |
| 5    | 0        | 2（0）             | 0（1）             | 1（0）             | 块 2     | 0 已在内存，访问位置 1                                            | 否     |
| 6    | 3        | 2（0）             | 0（0）             | 1（0）             | 块 3     | 扫描：<br>块 1（2，访问位 0）→ 替换为 3，访问位置 1；指针移到块 2 | 是     |
| 7    | 0        | 3（0）             | 0（1）             | 1（0）             | 块 2     | 0 已在内存，访问位置 1                                            | 否     |
| 8    | 4        | 3（0）             | 0（0）             | 1（0）             | 块 3     | 扫描：<br>块 1（3，访问位 0）→ 替换为 4，访问位置 1；指针移到块 2 | 是     |
| 9    | 2        | 4（0）             | 0（0）             | 1（0）             | 块 2     | 扫描：<br>块 1（4，访问位 0）→ 替换为 2，访问位置 1；指针移到块 2 | 是     |
| 10   | 3        | 2（0）             | 0（0）             | 1（0）             | 块 3     | 扫描：<br>块 1（2，访问位 0）→ 替换为 3，访问位置 1；指针移到块 2 | 是     |
| 11   | 0        | 3（0）             | 0（1）             | 1（0）             | 块 2     | 0 已在内存，访问位置 1                                            | 否     |
| 12   | 3        | 3（1）             | 0（0）             | 1（0）             | 块 1     | 3 已在内存，访问位置 1                                            | 否     |
| 13   | 2        | 3（0）             | 0（0）             | 1（0）             | 块 2     | 扫描：<br>块 1（3，访问位 0）→ 替换为 2，访问位置 1；指针移到块 2 | 是     |
| 14   | 1        | 2（0）             | 0（0）             | 1（1）             | 块 3     | 1 已在内存，访问位置 1                                            | 否     |
| 15   | 2        | 2（1）             | 0（0）             | 1（0）             | 块 1     | 2 已在内存，访问位置 1                                            | 否     |
| 16   | 0        | 2（0）             | 0（1）             | 1（0）             | 块 2     | 0 已在内存，访问位置 1                                            | 否     |
| 17   | 1        | 2（0）             | 0（0）             | 1（1）             | 块 3     | 1 已在内存，访问位置 1                                            | 否     |

通过这个例子可以看到，时钟算法通过“环形扫描+访问位重置”的机制，在保证公平性的同时，有效减少了不必要的页替换，是一种高效的页置换算法。

:::

### 改进型 CLOCK 算法

简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过就不需要执行 I/O 操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存

因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免 I/O 操作。这就是改进型的时钟置换算法的思想

修改位 = 0 ，表示页面没有被修改过；修改位 = 1 ，表示页面被修改过。为方便讨论，用（访问位，修改位）的形式表示各页面状态。如 `(1，1)` 表示一个页面近期被访问过且被修改过

- 算法规则

将所有可能被置换的页面排成一个循环队列

第一轮：从当前位置开始扫描到第一个 (0,0) 的帧用于替换。本轮扫描不修改任何标志位

第二轮：若第一轮扫描失败，则重新扫描，查找第一个 (0,1) 的帧用于替换。本轮将所有扫描过的帧访问位设为 0

第三轮：若第二轮扫描失败，则重新扫描，查找第一个 (0,0) 的帧用于替换。本轮扫描不修改任何标志位

第四轮：若第三轮扫描失败，则重新扫描，查找第一个 (0,1) 的帧用于替换

由于第二轮已将所有帧的访问位设为 0 ，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型 CLOCK 置换算法选择一个淘汰页面最多会进行四轮扫描

## 页面分配策略

需要了解的几个概念：

- 驻留集

指请求分页存储管理中给进程分配的物理块的集合。在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小

若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；
驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小

- 固定分配

操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变

- 可变分配

先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少，即驻留集大小可变

- 局部置换

发生缺页时只能选进程自己的物理块进行置换

- 全局置换

可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程

- 以上搭配可用性

| | 局部置换 | 全局置换 |
| --- | --- | --- |
| 固定分配 | √ | × |
| 可变分配 | √ | √ |

::: warning

全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配

:::

### 固定分配局部置换

系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）

### 可变分配全局置换

刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程：若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，**只要某进程发生缺页都将获得新的物理块**{#red-msg}，仅当空闲物理块用完时，系统才选择一个**未锁定**{#red-msg}的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个**被选中的进程拥有的物理块会减少，缺页率会增加**{#red-msg}

::: tip 锁定

系统会锁定一些页面，这些页面中的内容不能置换出外存（如：重要的内核数据可以设为“锁定”）

:::

### 可变分配局部置换

刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块

::: warning

可变分配全局置换：只要缺页就给分配新物理块
可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块

:::

### 何时调入页面

#### 预调页策略

根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有 50% 左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分

#### 请求调页策略

进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘 I/O 操作，因此 I/O 开销较大

### 从何处调入页面

- 系统拥有足够的对换区空间

页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前需将进程相关的数据从文件区复制到对换区

- 系统缺少足够的对换区空间

凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入

- UNIX 方式

运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入

::: tip 

外存（磁盘）中分为文件区和对换区两个部分：

- 文件区：读/写 速度更慢，采用离散分配方式
- 对换区：读/写 速度更快，采用连续分配方式

:::

### 抖动（颠簸）现象 :thumbsup:

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）

为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率

为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程“工作集”的概念