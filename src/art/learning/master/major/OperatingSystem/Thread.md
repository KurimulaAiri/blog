---
title: 线程
date: 2025-08-21
icon: 'gears'
order: 12
category: 
    - '408'
    - '操作系统'
    - 考研  
---

## 线程的概念

在没引入线程的概念之前，所有应用只能串行运行

有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。

传统进程是程序执行流的最小单位，引入线程后，线程成为了程序执行流的**最小单位**，可以把线程理解为“轻量级进程”

**线程**是一个**基本的 CPU 执行单元**，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的**各线程之间也可以并发**，从而进一步**提升了系统的并发度**，使得一个进程内也可以并发处理各种任务（如 QQ 视频、文字聊天、传文件等）

引入线程后，**进程只作为除 CPU 之外的系统资源的分配单元**（如打印机、内存地址空间等都是分配给进程的）

## 引入线程后与之前的区别

| 对比点 | 进程 | 线程 |
| :------: | :----: | :----: |
| 资源分配、调度 | 进程是资源分配、调度的基本单位 | 进程是资源分配的基本单位，线程是调度的基本单位 |
| 并发性 | 只能进程间并发 | 各线程间也能并发，提升了并发度 |
| 系统开销 | 进程间并发，需要切换进程的运行环境，系统开销很大 | 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小，引入线程后，并发所带来的系统开销减小 |

## 线程的属性

1. 线程是处理机调度的单位
2. 多 CPU 计算机中，各个线程可占用不同的 CPU （可以是同一个 CPU 的不同核心，也可以是不同的 CPU ）
3. 每个线程都有一个线程 ID 、线程控制块（ TCB ）
4. 线程也有就绪、阻塞、运行三种基本状态
5. 线程几乎不拥有系统资源
6. 同一进程的不同线程间共享进程的资源
7. 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
8. 同一进程中的线程切换，不会引起进程切换
9. 不同进程中的线程切换，会引起进程切换
10. 切换同进程内的线程，系统开销很小
11. 切换进程，系统开销较大

## 线程的实现方式

线程主要有两种实现方式：用户级线程（ User-Level Thread ， ULT ）和内核级线程（ Kernel-Level Thread ， KLT 又称“内核支持的线程”）

### 用户级线程

历史背景：早期的操作系统（如：早期 Unix ）只支持进程不支持线程。当时的“线程”是由线程库实现的

很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。

- 线程的管理工作由谁来完成？

用户级线程由应用程序通过线程库实现，**所有的线程管理工作都由应用程序负责**{#blue-msg}（包括线程切换）

- 线程切换是否需要 CPU 变换状态？

用户级线程中，**线程切换可以在用户态下即可完成**{#blue-msg}，无需操作系统干预

- 操作系统是否能意识到用户级线程的存在？

在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。**“用户级线程”就是“从用户视角看能看到的线程”**{#blue-msg}

- 这种线程的实现方式有什么优点和缺点？

    - 优点
    用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

    - 缺点
    当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高
    多个线程不可在多核处理机上并行运行

### 内核级线程

由操作系统支持的线程，大多数现代操作系统都实现了内核级线程，如 Windows 、 Linux 等

- 线程的管理工作由谁来完成？

**内核级线程的管理工作由操作系统内核完成**{#blue-msg}

- 线程切换是否需要 CPU 切换状态？

线程调度、切换等工作都由内核负责，因此**内核级线程的切换必然需要在核心态**{#blue-msg}下才能完成

- 操作系统是否能意识到内核级线程的存在？

操作系统会为每个内核级线程建立相应的 TCB （ ThreadControlBlock ，线程控制块）通过 TCB 对线程进行管理。**“内核级线程”就是“从操作系统内核视角看能看到的线程”**{#blue-msg}

- 这种线程的实现方式有什么优点和缺点？

    - 优点
    当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行

    - 缺点
    一个用户进程会占用多个内核级线程线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

## 多线程模型

为了结合两种线程的优点，引入了多线程模型

在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型

### 一对一模型

一个用户级线程映射到一个内核级线程
每个用户进程有与用户级线程同数量的内核级线程

- 优点

当一个线程被阻塞后，别的线程还可以继续执行，并发能力强
多线程可在多核处理机上并行执行

- 缺点

一个用户进程会占用多个内核级线程线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

### 多对一模型

多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程

- 优点

用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

- 缺点

当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

::: warning

**操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位**{#red-msg}

:::

### 多对多模型

![多对多模型](//store.s1r0ko.top/svg/m/os/12/1_ver_1.svg)

n 个用户级线程映射到 m 个内核级线程（ n $\ge$ m ）。每个用户进程对应 m 个内核级线程

克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点

可以这么理解:
用户级线程是“代码逻辑”的载体
内核级线程是“运行机会”的载体

内核级线程才是处理机分配的单位。例如:多核 CPU 环境下，上边这个进程最多能被分配两个核

一段“代码逻辑”只有获得了“运行机会”才能被 CPU 执行

内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞

## 线程的状态与转换

线程的状态与转换与进程的状态与转换完全一致

![线程的状态与转换](//store.s1r0ko.top/svg/m/os/12/2_ver_1.svg)

## 线程的组织与控制

![线程的组织与控制](//store.s1r0ko.top/svg/m/os/12/3_ver_1.svg)

与进程类似，线程的各种信息保存在线程控制块（ Thread Control Block ， TCB ）中

线程的各个 TCB 可以按照状态，进程，或者系统统一划分为线程表，各个操作系统不同

