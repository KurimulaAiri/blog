---
title: 进程同步与互斥
date: 2025-08-28
icon: 'gears'
order: 14
category: 
    - '408'
    - '操作系统'
    - 考研  
---

## 进程同步

同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作

并发性带来了异步性，有时需要通过进程同步解决这种异步问题。有的进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的**先后顺序**{#blue-msg}

## 进程互斥

进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的 I/O 设备）

### 资源的两种共享方式

- **互斥共享**

系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源，其他进程必须等待，直到该进程使用完毕，其他进程才能访问该资源。

- **同时共享**

系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问

### 临界资源

我们把一**个时间段内只允许一个进程使用的资源称为临界资源**{#blue-msg}。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源

对临界资源的访问，必须**互斥地进行**{#blue-msg}。互斥，亦称**间接制约关系**{#blue-msg}。**进程互斥**{#blue-msg}指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源

### 临界资源互斥访问的逻辑

对临界资源的互斥访问，可以在逻辑上分为如下四个部分（代码层面）：

- **进入区**{#red-msg}

负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志（可理解为“上锁”），以阻止其他进程同时进入临界区

- **临界区**{#red-msg}

访问临界资源的那段代码

- **退出区**{#red-msg}

负责解除正在访问临界资源的标志（可理解为“解锁”），以允许其他进程进入临界区

- **其他（剩余）区**

做其他处理

### 临界资源互斥访问的原则

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：

1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
2. 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待
3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）
4. 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待

## 进程互斥的软件实现方法

对于各软件算法的实现，需要从以下几个方面进行分析：

1. 理解各个算法的思想、原理
2. 结合上面部分的“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区都做了什么
3. 分析各算法存在的缺陷（结合“实现互斥要遵循的四个原则”进行分析）

### 单标志法

- **算法思想**

两个进程在**访问完临界区后**{#blue-msg}会把使用临界区的权限转交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予**{#blue-msg}

- **算法实现**

申明一个公共变量 turn ：

`int turn = 0; // turn 表示当前允许进入临界区的进程号`

现有两个进程 P0 、 P1 互斥访问一个设备

::: tabs

@tab P0 进程 

```c
while(turn != 0); // 进入区 ①
critical section; // 临界区 ②
turn = 1; // 退出区 ③
remainder section; // 剩余区 ④
```

@tab P1 进程

```c
while(turn != 1); // 进入区 ⑤
critical section; // 临界区 ⑥
turn = 0; // 退出区 ⑦
remainder section; // 剩余区 ⑧
```

:::

turn 的初值为 0 ，即刚开始只允许 0 号进程进入临界区。若 P1 先上处理机运行，则会一直卡在 ⑤ 。直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行代码 ① 不会卡住 P0 ， P0 可以正常访问临界区，在 P0 访问临界区期间即时切换回 P1 ， P1 依然会卡在只有 P0 在退出区将 turn 改为 1 后， P1 才能进入临界区

因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”

- **算法缺点**

只能按 P0 → P1 → P0 → P1 …… 这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0 ，而 P0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问。因此，单标志法存在的主要问题是：违背“空闲让进”原则

### 双标志先检查法

- **算法思想**

设置一个布尔型数组 `flag[]` ，数组中各个元素用来标记各进程想进入临界区的意愿，比如 `flag[0]= true` 意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 `flag[i]` 设为 `true` ，之后开始访问临界区

- **算法实现**



::: tabs

@tab 公共区代码

```c
bool flag[2];
flag[0] = false;
flag[1] = false;
```

@tab P0 进程

```c
while(flag[1]); // ①
flag[0] = true; // ②
critical section; // ③
flag[0] = false; // ④
remainder section;
```

@tab P1 进程

```c
while(flag[0]); // ⑤ 如果此时 P0 想进入临界区，P1 就一直循环等待
flag[1] = true; // ⑥ 标记为 P1 进程想要进入临界区
critical section; // ⑦ 访问临界区
flag[1] = false; // ⑧ 访问完临界区，修改标记为 P1 不想使用临界区
remainder section;
```

:::

- **算法缺点**

若按照 ①⑤②⑥③⑦ …… 的顺序执行， P0 和 P1 将会同时访问临界区

因此，双标志先检查法的主要问题是：违反“忙则等待”原则

原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换

### 双标志后检查法

- **算法思想**

双标志先检查法的改版。前一个算法的问题是**先“检查”后“上锁”**{#blue-msg}，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查的方法，来避免上述问题

- **算法实现**

::: tabs

@tab 公共区代码

```c
bool flag[2]; // 表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false; // 刚开始设置为两个进程都不想进入临界区
```

@tab P0 进程

```c
flag[0] = true; // ①
while(flag[1]); // ②
critical section; // ③
flag[0] = false; // ④
remainder section;
```

@tab P1 进程

```c
flag[1] = true; // ⑤ 标记为 P1 进程想要进入临界区
while(flag[0]); // ⑥ 如果 P0 也想进入临界区，则 P1 循环等待
critical section; // ⑦ 访问临界区
flag[1] = false; // ⑧ 访问完临界区，修改标记为 P1 不想使用临界区
remainder section;
```

:::

- **算法缺点**

若按照 ①⑤②⑥ …… 的顺序执行， P0 和 P1 将都无法进入临界区

因此，双标志后检查法虽然**解决了“忙则等待”**{#blue-msg}的问题，但是**又违背了“空闲让进”和“有限等待”**{#blue-msg}原则，会因各进程都长期无法访问临界资源而**产生“饥饿”**{#blue-msg}现象

### Peterson 算法

- **算法思想**

结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程

简而言之就是：

进入区：
1. 主动争取
2. 主动谦让
3. 检查对方是否也想使用，且最后一次是不是自己说了“客气话”

- **算法实现**

::: tabs

@tab 公共区代码

```c
bool flag[2]; // 表示进入临界区意愿的数组，初始值都是 false
int turn = 0; // turn 表示优先让哪个进程进入临界区
```

@tab P0 进程

```c
flag[0] = true; // ①
turn = 1; // ②
while(flag[1] && turn == 1); // ③
critical section; // ④
flag[0] = false; // ⑤
remainder section;
```

@tab P1 进程

```c
flag[1] = true; // ⑥ 表示自己想进入临界区
turn = 0; // ⑦ 可以优先让对方进入临界区
while(flag[0] && turn == 0); // ⑧ 对方想进，且最后一次是自己“让梨”，那自己就循环等待
critical section; // ⑨ 
flag[1] = false; // ⑩ 访问完临界区，表示自己已经不想访问临界区了
remainder section;
```

:::

- **算法缺点**

Peterson 算法用软件方法解决了进程互斥问题，遵循了**空闲让进、忙则等待、有限等待三个原则**{#blue-msg}，但是依然未遵循**让权等待**{#blue-msg}的原则

Peterson 算法相较于之前三种软件解决方案来说，是最好的，但依然不够好

## 进程互斥的硬件实现方法

主要了解：

1. 理解各方法的原理了解各方法的优缺点
2. 了解各方法的优缺点

### 中断屏蔽

- **原理**

利用“ 开/关 中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）

- **具体实现**

```pseudo
前置代码;
关中断;
临界区;
开中断;
后续代码;
```

关中断后即不允许当前进程被中断，也必然不会发生进程切换

直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区

- **优缺点**

    - 优点

        - 实现简单、高效

    - 缺点

        - 不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为 开/关 中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）

### TestAndSet 指令

- **原理**

简称 TS 指令，也有地方称为 TestAndSetLock 指令，或 TSL 指令 TSL 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。

- **具体实现**

`TestAndSet` 的逻辑可简化为以下伪代码（实际由硬件直接实现）：

```pseudo
// 共享变量 lock 表示临界区状态：
// true 表示被占用，false 表示空闲
boolean lock = false;

// 原子操作：TestAndSet
function TestAndSet(boolean *lock) {
    boolean oldValue = *lock;  // 读取当前值（测试）
    *lock = true;              // 设置为新值（设置）
    return oldValue;           // 返回操作前的旧值
}
```

实现互斥代码：

```pseudo
// 进程进入临界区的逻辑
while (TestAndSet(&lock)) {
    // 若返回 true，说明锁已被占用，循环等待（忙等）
}

// 临界区：访问共享资源
...

// 退出临界区时释放锁
lock = false;
```

若刚开始 lock 是 false，则 TSL 返回的 old 值为 false ， while 循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true ，则执行 TLS 后 old 返回的值为 true ， while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。

相比软件实现方法， TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作

- **优缺点**

    - 优点

    实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞：适用于多处理机环境

    - 缺点

    不满足“让权等待”原则，暂时无法进入临界区的进程会占用 CPU 并循环执行 TSL 指令，从而导致“忙等”

### swap 指令


