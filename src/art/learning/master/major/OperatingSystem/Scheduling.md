---
title: 调度
date: 2025-08-22
icon: 'gears'
order: 13
category: 
    - '408'
    - '操作系统'
    - 考研  
---

## 调度的概念

当有大量任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题

## 调度的三个层次

### 高级调度

内存空间有限，有时无法将用户提交的作业全部放入内存

**高级调度（作业调度）**{#blue-msg} —— 按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。**每个作业只调入一次，调出一次**{#red-msg}。作业调入时会建立 PCB ，调出时才撤销 PCB 

::: tip

作业：一个具体的任务

用户向系统提交一个作业 = 用户让操作系统启动一个程序（来处理一个具体的任务）

:::

### 低级调度

**低级调度（进程调度 / 处理机调度）**{#blue-msg} —— 按照某种策略从就绪队列中选取一个进程，将处理机分配给它

进程调度是操作系统中**最基本的一种调度**{#blue-msg}，在一般的操作系统中都必须配置进程调度进程调度的**频率很高**{#blue-msg}，一般几十毫秒一次

### 中级调度

内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存

暂时调到外存等待的进程状态为**挂起状态**{#blue-msg}。被挂起的进程 PCB 会被组织成**挂起队列**{#blue-msg}

**中级调度（内存调度）**{#blue-msg} —— 按照某种策略决定将哪个处于挂起状态的进程重新调入内存
一个进程可能会被多次调出、调入内存，因此**中级调度发生的频率要比高级调度更高**{#blue-msg}

### * 七状态模型

**考 408 仅了解，不要求记忆**{#red-msg}

暂时调到外存等待的进程状态为**挂起状态（挂起态， suspend ）**{#blue-msg}
挂起态又可以进一步细分为**就绪挂起、阻塞挂起**{#blue-msg}两种状态

**就绪挂起态（ ready-suspend ）**{#blue-msg}是指在就绪队列中等待的进程被移入外存中，**阻塞挂起态（ block-suspend ）**{#blue-msg}亦然

**阻塞挂起态**{#blue-msg}和就绪挂起态的进程可以在特定条件发生时激活并重新返回对应的队列中，某些操作系统中，处于**阻塞挂起态**{#blue-msg}的进程在等待到对应事件发生后也可以切换成**就绪挂起状态**{#blue-msg}

同样在某些操作系统中，刚创建完成的进程或**运行态**{#blue-msg}的进程在下处理机后会切换为**就绪挂起态**{#blue-msg}

::: warning

注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得 CPU 的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中

有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列

:::

### 三种调度的联系和对比

| 调度类型 / 对比项 | 要做什么 | 调度发生在哪 | 发生频率 | 对进程状态的影响 |
| :---: | :---: | :---: | :---: | :---: |
| 高级调度（作业调度） | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存→内存（面向作业） | 最低 | 无→创建态→就绪态 |
| 低级调度（内存调度） | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存 | 外存→内存（面向进程） | 中等 | 挂起态→就绪态（阻塞挂起→阻塞态） |
| 中级调度（进程调度） | 按照某种规则，从就绪队列中选择一个进程为其分配处理机 | 内存→ CPU | 最高 | 就绪态→运行态 |

## 进程调度的时机

进程调度（低级调度）就是按照某种规则，从就绪队列中选择一个进程为其分配处理机

- **需要进行**{#red-msg}进程调度与切换的情况

    - 当前运行的进程**主动放弃**{#red-msg}处理机

        - 进程正常终止
        - 运行过程中发生异常而终止
        - 进程主动请求阻塞（如等待 I/O ）

    - 当前运行的进程**被动放弃**{#red-msg}处理机

        - 分给进程的时间片用完
        - 有更紧急的事需要处理（如 I/O 中断）
        - 有更高优先级的进程进入就绪队列

- **不能进行**{#red-msg}进程调度与切换的情况

    - 在**处理中断的过程**{#red-msg}中，中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换
    - 进程在**操作系统内核程序临界区**{#red-msg}中
    - 在**原子操作过程中（原语）**{#red-msg}，原子操作不可中断，要一气呵成（如之前讲过的修改 PCB 中进程状态标志，并把 PCB 放到相应队列）

在某些操作系统中，不允许应用程序被动放弃处理机；而有的操作系统会因为更加紧急的进程需要执行而强行剥夺当前运行进程的处理机，这就引出了[进程的调度方式](#进程调度的方式)

## 进程调度的方式

进程的调度方式有两种：**非剥夺调度方式**和**剥夺调度方式**

### 非剥夺调度方式

**非剥夺调度方式**{#blue-msg}，又称**非抢占方式**{#blue-msg}。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态

实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统

### 剥夺调度方式

**剥夺调度方式**{#blue-msg}，又称**抢占方式**{#blue-msg}。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程

可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统

## 进程的切换

“狭义的进程调度”与“进程切换”的区别：

**狭义的进程调度**指的是从就绪队列中**选中一个要运行的进程**{#red-msg}。（这个进程可以是刚刚被暂停执行的进程也可能是另一个进程，后一种情况就需要**进程切换**{#red-msg}）
进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程

**广义的进程调度**包含了选择一个进程和进程切换两个步骤

进程切换的过程主要完成了：

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复
（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

::: warning

**进程切换是有代价的**{#red-msg}，因此如果**过于频繁的进行**{#red-msg}进程**调度**{#red-msg}、**切换**{#red-msg}，必然会使整个**系统的效率降低**{#red-msg},使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少

:::

## 调度器 / 调度程序

对于不支持线程的操作系统，调度程序操作的对象是**进程**{#blue-msg}；

对于支持线程的操作系统，调度程序操作的对象是**内核线程**{#blue-msg}；

![线程不同的状态](//store.s1r0ko.top/svg/m/os/12/2_ver_1.svg)

选中和时间片用完导致的状态变换由**调度器 / 调度程序（ Scheduler ）**{#red-msg}引起

调度程序决定：

- 让谁运行？ —— 调度算法

- 运行多长时间？ —— 时间片大小

- 调度时机？ —— 什么事件会触发“调度程序”？

    - **创建新进程**{#red-msg}
    - **进程退出**{#red-msg}
    - **运行进程阻塞**{#red-msg}
    - **I/O 中断发生**{#red-msg}（可能唤醒某些阻塞进程）
    - 非抢占式调度策略，只有运行进程阻塞或退出才触发调度程序工作
    - 抢占式调度策略，每个**时钟中断**{#blue-msg}或 k 个时钟中断会触发调度程序工作

## 闲逛进程

调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程（ idle 进程）

- 闲逛进程的特性：

    - 优先级最低
    - 可以是 0 地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）
    - 能耗低

## 调度算法的评价指标

通常通过下面几个指标来评价某种调度算法的性能

### CPU 利用率 :thumbsup:

由于早期的 CPU 造价极其昂贵，因此人们会希望让 CPU 尽可能多地工作

CPU 利用率：指 CPU “忙碌”的时间占总时间的比例

$$

\text{CPU 利用率} = \frac{\text{忙碌时间}}{\text{总时间}}

$$

::: tip

有的题目还会要求计算某种设备的利用率

eg. 某计算机只支持单道程序，某个作业刚开始需要在 CPU 上运行 5 秒，再用打印机打印输出 5 秒，之后再执行 5 秒，才能结束。在此过程中， CPU 利用率、打印机利用率分别是多少？

$$

\begin{align*}
\text{CPU 利用率} = \frac{5 + 5}{5 + 5 + 5} = \frac{10}{15} = 0.667
\\
\\
\text{打印机利用率} = \frac{5}{5 + 5 + 5} = \frac{5}{15} = 0.333
\end{align*}

$$

:::

### 系统吞吐量 :thumbsup:

对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业，这就是系统吞吐量

系统吞吐量：单位时间内完成作业的数量

$$

\text{系统吞吐量} = \frac{\text{完成作业的数量}}{\text{单位时间}}

$$

eg. 某计算机系统处理完 10 道作业，共花费 100 秒，则系统吞吐量为？

$$

\text{系统吞吐量} = \frac{10}{100} = 0.1 \text{ 道 / 秒}

$$

### 周转时间 :thumbsup:

对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间

周转时间，是指从**作业被提交给系统开始**{#blue-msg}，到**作业完成为止**{#blue-msg}的这段时间间隔
它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在 CPU 上执行的时间、进程等待 I/O 操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。

$$

\begin{align*}
\text{（作业）周转时间} = \text{作业完成时间} - \text{作业被提交时间}
\\
\\
\text{平均周转时间} = \frac{\text{各作业周转时间之和}}{\text{作业数}}
\end{align*}

$$

::: tip

有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的

对此，我们可以引入**带权周转时间**{#blue-msg}

$$

\begin{align*}
\text{带权周转时间} = \frac{\text{作业周转时间}}{\text{作业实际运行时间}} = \frac{\text{作业完成时间} - \text{作业被提交时间}}{\text{作业实际运行时间}}
\\
\\
\text{平均带权周转时间} = \frac{\text{各作业带权周转时间之和}}{\text{作业数}}
\end{align*}

$$

带权周转时间必然 $\ge$ 1
带权周转时间与周转时间都是越小越好

对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高
对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高

:::

### 等待时间

计算机的用户希望自己的作业尽可能少的等待处理机
等待时间，指进程 / 作业**处于等待处理机状态时间之和**{#blue-msg}，等待时间越长，用户满意度越低

对于**进程**{#blue-msg}来说，等待时间就是指进程建立后**等待被服务的时间之和**{#blue-msg}，在等待 I/O 完成的期间其实进程也是在被服务的，所以不计入等待时间

对于**作业**{#blue-msg}来说，不仅要考虑**建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间**{#blue-msg}

$$

\begin{align*}
\text{（进程）等待时间} = \text{周转时间} - \text{运行时间} - \text{I/O 操作总时长（等待 I/O 时间 + I/O 操作时间）}
\end{align*}

$$

::: tip

作业会在外存中的后备队列等待被服务（调度）

作业调入内存后，建立对应的进程。这个进程会被 CPU 服务、会被 I/O 设备服务，当然也会有等待被服务的时候（比如等待 I/O 完成）

:::

一个作业总共需要被 CPU 服务多久，被 I/O 设备服务多久一般是确定不变的，因此调度算法其实只会影响作业 / 进程的等待时间。当然，与前面指标类似，也有“**平均等待时间**{#blue-msg}”来评价整体性能

### 响应时间

对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应

响应时间，指从用户**提交请求**{#blue-msg}到**首次产生响应**{#blue-msg}所用的时间。响应时间越小，用户满意度越高

## 调度算法

将按照以下框架分析各个算法

1. 算法思想

2. 算法规则

3. 这种调度算法是用于**作业调度**{#blue-msg}还是**进程调度**{#blue-msg}？

4. 该算法是抢占式？还是非抢占式？

5. 优点和缺点

6. 是否会导致**饥饿**{#red-msg}（某进程 / 作业长期得不到服务）

### 先来先服务

::: info 先来先服务算法（ First Come First Serve ， FCFS ）

- **算法思想**

主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）

- **算法规则**

按照作业 / 进程到达的先后顺序进行服务

- **用于作业 / 进程调度**

用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列

- **是否可抢占**

非抢占式的算法

- **优缺点**

- **是否会导致饥饿**


eg. 各进程到达就绪队列的时间、需要的运行时间如下表所示。使用**先来先服务**{#blue-msg}调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间

| 进程 | 到达时间 | 运行时间 |
| :---: | :---: | :---: |
|  P1  |  0  |  7  |
|  P2  |  2  |  4  |
|  P3  |  4  |  1  |
|  P4  |  5  |  4  |

先来先服务调度算法：按照到达的先后顺序调度，事实上就是**等待时间越久**{#blue-msg}的越优先得到服务

因此，调度顺序为： P1 → P2 → P3 → P4

周转时间：$\text{（作业）周转时间} = \text{作业完成时间} - \text{作业被提交时间}$

P1 = 7 - 0 = 7
P2 = 11 - 2 = 9
P3 = 12 - 4 = 8
P4 = 16 - 5 = 11

带权周转时间：$\text{带权周转时间} = \frac{\text{作业周转时间}}{\text{作业实际运行时间}}$

P1 = 7 / 7 = 1
P2 = 9 / 4 = 2.25
P3 = 8 / 1 = 8
P4 = 11 / 4 = 2.75

等待时间：$\text{等待时间} = \text{周转时间} - \text{运行时间}$

P1 = 7 - 7 = 0
P2 = 9 - 4 = 5
P3 = 8 - 1 = 7
P4 = 11 - 4 = 7

::: warning 

本例中的进程都是纯计算型的进程，一个进程到达后要么在等待，要么在运行。如果是又有计算、又有 I/O 操作的进程，其等待时间就是**周转时间-运行时间- I/O 操作的时间**{#blue-msg}

:::

