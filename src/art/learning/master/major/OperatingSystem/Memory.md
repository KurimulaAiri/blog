---
title: 内存
date: 2025-09-25
icon: 'gears'
order: 18
category: 
    - '408'
    - '操作系统'
    - 考研  
---

## 内存的基础知识 :thumbsup:

内存可存放数据。程序执行前需要先放到内存中才能被 CPU 处理——缓和 CPU 与硬盘之间的速度矛盾

内存地址从 0 开始，每个地址对应一个存储单元
内存中也有一个一个的“小房间”，每个小房间就是一个“存储单元”
如果计算机“按字节编址”则每个存储单元大小为 1 字节，即 1B ，即 8 个二进制位
如果字长为 16 位的计算机“按字编址”，则每个存储单元大小为 1 个字;每个字的大小为 16 个二进制位

## 一些数量单位

1 B = 8 位（bit）
1 KB = 1024 B = $2^{10}$ B
1 MB = 1024 KB = $2^{20}$ B
1 GB = 1024 MB = $2^{30}$ B
1 TB = 1024 GB = $2^{40}$ B

程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址），即:相对于进程的起始地址而言的地址

## 如何通过逻辑地址获取物理地址 :thumbsup:

主要有三种方式：

### 绝对装入

在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码

装入程序按照装入模块中的地址，将程序和数据装入内存

绝对装入**只适用于单道程序环境**{#red-msg}

### 可重定位装入（静态重定位）

又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）

一般是多道批处理程序使用

### 动态运行时装入（动态重定位）

静态重定位的特点是在一个作业装入内存时，**必须分配其要求的全部内存空间**{#red-msg}，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，**在运行期间就不能再移动**{#red-msg}，也不能再申请内存空间

又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行**{#red-msg}。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个**重定位寄存器**{#red-msg}的支持

::: tip 重定位寄存器的作用

存放装入模块存放的**起始位置**{#blue-msg}

:::

采用动态重定位时**允许程序在内存中发生移动**{#red-msg}，并且可将程序分配到不连续的存储区中;在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存;便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间

现代操作系统多使用动态运行时装入方式

## 从高级语言到程序 :thumbsup:

编译：将高级语言编写的程序转换为机器语言的程序（每个高级语言文件对应一个目标模块，通常为 `*.o` 的拓展名）

链接：将编译后的多个目标模块与所需的库函数链接起来，组装生成一个可执行文件（装入模块）

## 链接的三种方式 :thumbsup:

- **静态链接**

在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开

- **装入时动态链接**

将各目标模块装入内存时，边装入边链接的链接方式

- **运行时动态链接** :thumbsup:

在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享

## 内存管理

操作系统需要对实现以下四个功能以实现内存管理

1. **内存的分配与回收**

2. **对内存空间进行扩充**

操作系统需要提供某种技术从逻辑上对内存空间进行扩充

3. **地址转换（三种装入方式）**

为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况

4. **内存保护**

操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰

内存保护一般使用两种方法

- **设置一对上、下限寄存器**

在 CPU 中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时， CPU 检查是否越界

- **越界检查**

采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址

## 进程的内存映像

![内存映像模型](https://store.s1r0ko.top/svg/m/os/18/1_ver_1.svg)

假设此时有一段这样的 C 语言代码

```c
#include <stdio.h>
#define X 1024 // 定义一个宏 X，值为 1024
int a = 1; // 全局变量 a，值为 1
const int b = 2; // 全局常量 b，值为 2
int main() 
{
    static int c = 3; // 静态局部变量 c，值为 3
    int d = 4; // 局部变量 d，值为 4
    int *p = (int *)malloc(sizeof(int) * 10); // 动态分配内存，p 指向该内存
    a = b + c + d; // a = 2 + 3 + 4 = 9
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```
那么不同部分位于的内存区域如下

- **操作系统内核区**

进程控制块 PCB 等数据

- **栈区**

在函数大括号内定义的局部变量、函数调用时传入的参数

- **堆区**

动态分配的内存（如 malloc 函数申请和 free 释放的内存）存储在堆区

- **共享库的存储映射区**

被调用的库函数的代码和数据存储在共享库的存储映射区

- **读写数据**

定义在函数外的全局变量、由 static 关键字修饰的变量

- **只读代码/数据段**

程序代码、由 const 关键字修饰的变量

::: code-tabs

@tab 栈

```c
#include <stdio.h>
#define X 1024 
int a = 1; 
const int b = 2; 
int main() 
{
    static int c = 3; 
    int d = 4; // [!code highlight]
    int *p = (int *)malloc(sizeof(int) * 10); // 等号前面的部分 [!code highlight] 
    a = b + c + d; 
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 共享库的存储映射区

```c
#include <stdio.h> // [!code highlight]
#define X 1024 
int a = 1; 
const int b = 2; 
int main() 
{
    static int c = 3; 
    int d = 4; 
    int *p = (int *)malloc(sizeof(int) * 10); 
    a = b + c + d; 
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 堆

```c
#include <stdio.h>
#define X 1024 
int a = 1; 
const int b = 2; 
int main() 
{
    static int c = 3; 
    int d = 4; 
    int *p = (int *)malloc(sizeof(int) * 10); // malloc 开辟的内存 [!code highlight] 
    a = b + c + d; 
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 读写数据段

```c
#include <stdio.h>
#define X 1024 
int a = 1; // [!code highlight]
const int b = 2; 
int main() 
{
    static int c = 3; // [!code highlight]
    int d = 4; 
    int *p = (int *)malloc(sizeof(int) * 10); 
    a = b + c + d; 
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 只读代码/数据段

```c 
#include <stdio.h>
#define X 1024 
int a = 1; 
const int b = 2; // [!code highlight]
int main() 
{
    static int c = 3; 
    int d = 4; 
    int *p = (int *)malloc(sizeof(int) * 10); 
    a = b + c + d; // [!code highlight]
    for (int i = 0; i < 10; i++) // [!code highlight]
    { // [!code highlight]
        p[i] = X + i; // [!code highlight]
    } // [!code highlight]
    printf("hello world \n"); // [!code highlight]
    return 0; // [!code highlight]
}
```

:::

::: warning 宏定义的变量

宏定义的变量是在预处理阶段展开的，所以在编译时，宏定义的变量会被替换为其对应的值。因此，宏定义的变量会隐含在只读数据段中。（也就是在编译时，宏定义的变量被使用的地方的宏变量名会被替换为其对应的值）

在本例中，所有使用到宏定义的变量 X 都会被替换为 1024。

:::

## 内存的分配与回收

以为用户进程分配的内存是否连续，内存的分配方式区分为连续分配管理方式和非连续分配管理方式。

### 连续分配管理方式

#### 单一连续分配

在单一连续分配方式中，内存被分为**系统区**和**用户区**。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。内存中**只能有一道用户程序**，用户程序独占整个用户区空间。

- 优点
    - 实现简单；
    - 无外部碎片；
    - 可以采用覆盖技术扩充内存：不一定需要采取内存保护（ eg: 早期的PC操作系统 MS-DOS ）

- 缺点

    - 只能用于单用户、单任务的操作系统中；
    - 有内部碎片；
    - 存储器利用率极低

::: tip 内部碎片

分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”

:::

#### 固定分区分配

20 世纪 60 年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个**用户空间**划分为**若干个固定大小的分区**，在**每个分区中只装入一道作业**，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式

固定分区分配又分为**分区大小相等**和**分区大小不等**

- 分区大小相等

    缺乏灵活性，但是很**适合用于用一台计算机控制多个相同对象的场合**（比如：钢铁厂有 n 个相同的炼钢炉，就可把内存分为 n 个大小相等的区域存放 n 个炼钢炉控制程序）

- 分区大小不等

    增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）



### 非连续分配管理方式
