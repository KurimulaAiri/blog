---
title: 内存
date: 2025-09-25
icon: 'gears'
order: 18
category: 
    - '408'
    - '操作系统'
    - 考研  
---

## 内存的基础知识 :thumbsup:

内存可存放数据。程序执行前需要先放到内存中才能被 CPU 处理——缓和 CPU 与硬盘之间的速度矛盾

内存地址从 0 开始，每个地址对应一个存储单元
内存中也有一个一个的“小房间”，每个小房间就是一个“存储单元”
如果计算机“按字节编址”则每个存储单元大小为 1 字节，即 1B ，即 8 个二进制位
如果字长为 16 位的计算机“按字编址”，则每个存储单元大小为 1 个字;每个字的大小为 16 个二进制位

## 一些数量单位

1 B = 8 位（bit）
1 KB = 1024 B = $2^{10}$ B
1 MB = 1024 KB = $2^{20}$ B
1 GB = 1024 MB = $2^{30}$ B
1 TB = 1024 GB = $2^{40}$ B

程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址），即:相对于进程的起始地址而言的地址

## 如何通过逻辑地址获取物理地址 :thumbsup:

主要有三种方式：

### 绝对装入

在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码

装入程序按照装入模块中的地址，将程序和数据装入内存

绝对装入**只适用于单道程序环境**{#red-msg}

### 可重定位装入（静态重定位）

又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）

一般是多道批处理程序使用

### 动态运行时装入（动态重定位）

静态重定位的特点是在一个作业装入内存时，**必须分配其要求的全部内存空间**{#red-msg}，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，**在运行期间就不能再移动**{#red-msg}，也不能再申请内存空间

又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行**{#red-msg}。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个**重定位寄存器**{#red-msg}的支持

::: tip 重定位寄存器的作用

存放装入模块存放的**起始位置**{#blue-msg}

:::

采用动态重定位时**允许程序在内存中发生移动**{#red-msg}，并且可将程序分配到不连续的存储区中;在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存;便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间

现代操作系统多使用动态运行时装入方式

## 从高级语言到程序 :thumbsup:

编译：将高级语言编写的程序转换为机器语言的程序（每个高级语言文件对应一个目标模块，通常为 `*.o` 的拓展名）

链接：将编译后的多个目标模块与所需的库函数链接起来，组装生成一个可执行文件（装入模块）

## 链接的三种方式 :thumbsup:

- **静态链接**

在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开

- **装入时动态链接**

将各目标模块装入内存时，边装入边链接的链接方式

- **运行时动态链接** :thumbsup:

在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享

## 内存管理

操作系统需要对实现以下四个功能以实现内存管理

1. **内存的分配与回收**

2. **对内存空间进行扩充**

操作系统需要提供某种技术从逻辑上对内存空间进行扩充

3. **地址转换（三种装入方式）**

为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况

4. **内存保护**

操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰

内存保护一般使用两种方法

- **设置一对上、下限寄存器**

在 CPU 中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时， CPU 检查是否越界

- **越界检查**

采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址

## 进程的内存映像

![内存映像模型](https://store.s1r0ko.top/svg/m/os/18/1_ver_1.svg)

假设此时有一段这样的 C 语言代码

```c
#include <stdio.h>
#define X 1024 // 定义一个宏 X，值为 1024
int a = 1; // 全局变量 a，值为 1
const int b = 2; // 全局常量 b，值为 2
int main() 
{
    static int c = 3; // 静态局部变量 c，值为 3
    int d = 4; // 局部变量 d，值为 4
    int *p = (int *)malloc(sizeof(int) * 10); // 动态分配内存，p 指向该内存
    a = b + c + d; // a = 2 + 3 + 4 = 9
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```
那么不同部分位于的内存区域如下

- **操作系统内核区**

进程控制块 PCB 等数据

- **栈区**

在函数大括号内定义的局部变量、函数调用时传入的参数

- **堆区**

动态分配的内存（如 malloc 函数申请和 free 释放的内存）存储在堆区

- **共享库的存储映射区**

被调用的库函数的代码和数据存储在共享库的存储映射区

- **读写数据**

定义在函数外的全局变量、由 static 关键字修饰的变量

- **只读代码/数据段**

程序代码、由 const 关键字修饰的变量

::: code-tabs

@tab 栈

```c
#include <stdio.h>
#define X 1024 
int a = 1; 
const int b = 2; 
int main() 
{
    static int c = 3; 
    int d = 4; // [!code highlight]
    int *p = (int *)malloc(sizeof(int) * 10); // 等号前面的部分 [!code highlight] 
    a = b + c + d; 
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 共享库的存储映射区

```c
#include <stdio.h> // [!code highlight]
#define X 1024 
int a = 1; 
const int b = 2; 
int main() 
{
    static int c = 3; 
    int d = 4; 
    int *p = (int *)malloc(sizeof(int) * 10); 
    a = b + c + d; 
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 堆

```c
#include <stdio.h>
#define X 1024 
int a = 1; 
const int b = 2; 
int main() 
{
    static int c = 3; 
    int d = 4; 
    int *p = (int *)malloc(sizeof(int) * 10); // malloc 开辟的内存 [!code highlight] 
    a = b + c + d; 
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 读写数据段

```c
#include <stdio.h>
#define X 1024 
int a = 1; // [!code highlight]
const int b = 2; 
int main() 
{
    static int c = 3; // [!code highlight]
    int d = 4; 
    int *p = (int *)malloc(sizeof(int) * 10); 
    a = b + c + d; 
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 只读代码/数据段

```c 
#include <stdio.h>
#define X 1024 
int a = 1; 
const int b = 2; // [!code highlight]
int main() 
{
    static int c = 3; 
    int d = 4; 
    int *p = (int *)malloc(sizeof(int) * 10); 
    a = b + c + d; // [!code highlight]
    for (int i = 0; i < 10; i++) // [!code highlight]
    { // [!code highlight]
        p[i] = X + i; // [!code highlight]
    } // [!code highlight]
    printf("hello world \n"); // [!code highlight]
    return 0; // [!code highlight]
}
```

:::

::: warning 宏定义的变量

宏定义的变量是在预处理阶段展开的，所以在编译时，宏定义的变量会被替换为其对应的值。因此，宏定义的变量会隐含在只读数据段中。（也就是在编译时，宏定义的变量被使用的地方的宏变量名会被替换为其对应的值）

在本例中，所有使用到宏定义的变量 X 都会被替换为 1024。

:::

## 内存的分配与回收

以为用户进程分配的内存是否连续，内存的分配方式区分为连续分配管理方式和非连续分配管理方式。

### 连续分配管理方式

#### 单一连续分配

在单一连续分配方式中，内存被分为**系统区**和**用户区**。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。内存中**只能有一道用户程序**，用户程序独占整个用户区空间。

- 优点
    - 实现简单；
    - 无外部碎片；
    - 可以采用覆盖技术扩充内存：不一定需要采取内存保护（ eg: 早期的PC操作系统 MS-DOS ）

- 缺点

    - 只能用于单用户、单任务的操作系统中；
    - 有内部碎片；
    - 存储器利用率极低

::: tip 内部碎片

分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”

:::

#### 固定分区分配

20 世纪 60 年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个**用户空间**划分为**若干个固定大小的分区**，在**每个分区中只装入一道作业**，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式

固定分区分配又分为**分区大小相等**和**分区大小不等**

- 分区大小相等

    缺乏灵活性，但是很**适合用于用一台计算机控制多个相同对象的场合**（比如：钢铁厂有 n 个相同的炼钢炉，就可把内存分为 n 个大小相等的区域存放 n 个炼钢炉控制程序）

- 分区大小不等

    增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）

    操作系统需要建立一个数据结构——**分区说明表**，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的**大小、起始地址、状态(是否已分配)**{#blue-msg}

    类似于：

    | 分区号 | 分区大小（单位：KB） | 起始地址（单位：K） | 状态 |
    | --- | -------- | -------- | ---- |
    | 1 | 2 | 8 | 未分配 |
    | 2 | 2 | 10 | 未分配 |
    | 3 | 4 | 12 | 已分配 |
    | …… | …… | …… | …… |

    当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”

    - 优点：实现简单，无外部碎片

    - 缺点：
        - 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能;
        - 会产生内部碎片，内存利用率低

#### 动态分区分配

**动态分区分配又称为可变分区分配**。这种分配方式**不会预先划分内存分区**，而是在进程装入内存时**根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg: 假设某计算机内存大小为 64 MB ，系统区 8 MB ，用户区共 56 MB ……）

具体实现可以采用空闲分区表或空闲分区链表来管理空闲分区。

- **空闲分区表**

每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息

- **空闲分区链表**

每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息

---

动态分区分配没有内部碎片，但是有外部碎片

**内部碎片**：分配给某进程的内存区域中，如果有些部分没有用上
**外部碎片**：是指内存中的某些空闲分区由于太小而难以利用

如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求

可以通过**紧凑（拼凑，Compaction）**{#blue-msg}技术来解决外部碎片。

##### 动态分区分配的算法

::: info 首次适应算法（First Fit）

- **算法思想**

    从内存的低地址开始，顺序查找空闲分区表，找到第一个能满足进程需求的分区，将之分配给进程，若进程大小大于该分区大小，则将该分区一分为二，将低地址部分分配给进程，高地址部分则作为新的空闲分区加入到空闲分区表中。若进程大小小于该分区大小，则将该分区全部分配给进程。

- **实现方式**

    **空闲分区以地址递增的次序排列**{#blue-msg}。每次分配内存时顺序查找**空闲分区链**{#blue-msg}（或**空闲分区表**{#blue-msg}），找到大小能满足要求的第一个空闲分区

:::

::: tip 最佳适应算法（Best Fit）

- **算法思想**

    由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区即，优先使用更小的空闲区

- **实现方式**

    空闲分区**按容量递增次序链接**{#blue-msg}。每次分配内存时顺序查找**空闲分区链**{#blue-msg}（或**空闲分区表**{#blue-msg}），找到大小能满足要求的第一个空闲分区

- **缺点**

    **每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片**{#red-msg}

:::

::: warning 最坏适应算法（Worst Fit）

又称**最大适应算法**{#blue-msg}(Largest Fit)

- **算法思想**

    为了解决最佳适应算法的问题--即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

- **实现方式**

    空闲分区**按容量递减次序链接**{#blue-msg}。每次分配内存时顺序查找**空闲分区链**{#blue-msg}（或**空闲分区表**{#blue-msg}），找到大小能满足要求的第一个空闲分区

- **缺点**

    **每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了**{#red-msg}

:::

::: caution 近邻适应算法（Next Fit）

- **算法思想**

    首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题

- **实现方式**

    空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时**从上次查找结束的位置**开始查找**空闲分区链**（或**空闲分区表**），找到大小能满足要求的第一个空闲分区。

- **优点**

    **首次适应算法每次都要从头查找，每次都需要检索低地址的小分区但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）**{#blue-msg}。

- **缺点**

    **邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）**{#red-msg}

:::

综合来看，四种算法中，**首次适应算法**{#red-msg}的效果反而更好

### 非连续分配管理方式
