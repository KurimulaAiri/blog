---
title: 内存
date: 2025-09-25
icon: 'gears'
order: 18
category:
  - '408'
  - '操作系统'
  - 考研
---

## 内存的基础知识 :thumbsup:

内存可存放数据。程序执行前需要先放到内存中才能被 CPU 处理——缓和 CPU 与硬盘之间的速度矛盾

内存地址从 0 开始，每个地址对应一个存储单元
内存中也有一个一个的“小房间”，每个小房间就是一个“存储单元”
如果计算机“按字节编址”则每个存储单元大小为 1 字节，即 1B ，即 8 个二进制位
如果字长为 16 位的计算机“按字编址”，则每个存储单元大小为 1 个字;每个字的大小为 16 个二进制位

## 一些数量单位

1 B = 8 位（bit）
1 KB = 1024 B = $2^{10}$ B
1 MB = 1024 KB = $2^{20}$ B
1 GB = 1024 MB = $2^{30}$ B
1 TB = 1024 GB = $2^{40}$ B

程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址），即:相对于进程的起始地址而言的地址

## 如何通过逻辑地址获取物理地址 :thumbsup:

主要有三种方式：

### 绝对装入

在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码

装入程序按照装入模块中的地址，将程序和数据装入内存

绝对装入**只适用于单道程序环境**{#red-msg}

### 可重定位装入（静态重定位）

又称可重定位装入。编译、链接后的装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）

一般是多道批处理程序使用

### 动态运行时装入（动态重定位）

静态重定位的特点是在一个作业装入内存时，**必须分配其要求的全部内存空间**{#red-msg}，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，**在运行期间就不能再移动**{#red-msg}，也不能再申请内存空间

又称动态运行时装入。编译、链接后的装入模块的地址都是从 0 开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行**{#red-msg}。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个**重定位寄存器**{#red-msg}的支持

::: tip 重定位寄存器的作用

存放装入模块存放的**起始位置**{#blue-msg}

:::

采用动态重定位时**允许程序在内存中发生移动**{#red-msg}，并且可将程序分配到不连续的存储区中;在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存;便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间

现代操作系统多使用动态运行时装入方式

## 从高级语言到程序 :thumbsup:

编译：将高级语言编写的程序转换为机器语言的程序（每个高级语言文件对应一个目标模块，通常为 `*.o` 的拓展名）

链接：将编译后的多个目标模块与所需的库函数链接起来，组装生成一个可执行文件（装入模块）

## 链接的三种方式 :thumbsup:

- **静态链接**

在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开

- **装入时动态链接**

将各目标模块装入内存时，边装入边链接的链接方式

- **运行时动态链接** :thumbsup:

在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享

## 内存管理

操作系统需要对实现以下四个功能以实现内存管理

1. **内存的分配与回收**

2. **对内存空间进行扩充**

操作系统需要提供某种技术从逻辑上对内存空间进行扩充

3. **地址转换（三种装入方式）**

为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况

4. **内存保护**

操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰

内存保护一般使用两种方法

- **设置一对上、下限寄存器**

在 CPU 中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时， CPU 检查是否越界

- **越界检查**

采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址

## 进程的内存映像

![内存映像模型](https://store.s1r0ko.top/svg/m/os/18/1_ver_1.svg)

假设此时有一段这样的 C 语言代码

```c
#include <stdio.h>
#define X 1024 // 定义一个宏 X，值为 1024
int a = 1; // 全局变量 a，值为 1
const int b = 2; // 全局常量 b，值为 2
int main()
{
    static int c = 3; // 静态局部变量 c，值为 3
    int d = 4; // 局部变量 d，值为 4
    int *p = (int *)malloc(sizeof(int) * 10); // 动态分配内存，p 指向该内存
    a = b + c + d; // a = 2 + 3 + 4 = 9
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

那么不同部分位于的内存区域如下

- **操作系统内核区**

进程控制块 PCB 等数据

- **栈区**

在函数大括号内定义的局部变量、函数调用时传入的参数

- **堆区**

动态分配的内存（如 malloc 函数申请和 free 释放的内存）存储在堆区

- **共享库的存储映射区**

被调用的库函数的代码和数据存储在共享库的存储映射区

- **读写数据**

定义在函数外的全局变量、由 static 关键字修饰的变量

- **只读代码/数据段**

程序代码、由 const 关键字修饰的变量

::: code-tabs

@tab 栈

```c
#include <stdio.h>
#define X 1024
int a = 1;
const int b = 2;
int main()
{
    static int c = 3;
    int d = 4; // [!code highlight]
    int *p = (int *)malloc(sizeof(int) * 10); // 等号前面的部分 [!code highlight]
    a = b + c + d;
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 共享库的存储映射区

```c
#include <stdio.h> // [!code highlight]
#define X 1024
int a = 1;
const int b = 2;
int main()
{
    static int c = 3;
    int d = 4;
    int *p = (int *)malloc(sizeof(int) * 10);
    a = b + c + d;
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 堆

```c
#include <stdio.h>
#define X 1024
int a = 1;
const int b = 2;
int main()
{
    static int c = 3;
    int d = 4;
    int *p = (int *)malloc(sizeof(int) * 10); // malloc 开辟的内存 [!code highlight]
    a = b + c + d;
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 读写数据段

```c
#include <stdio.h>
#define X 1024
int a = 1; // [!code highlight]
const int b = 2;
int main()
{
    static int c = 3; // [!code highlight]
    int d = 4;
    int *p = (int *)malloc(sizeof(int) * 10);
    a = b + c + d;
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 只读代码/数据段

```c
#include <stdio.h>
#define X 1024
int a = 1;
const int b = 2; // [!code highlight]
int main()
{
    static int c = 3;
    int d = 4;
    int *p = (int *)malloc(sizeof(int) * 10);
    a = b + c + d; // [!code highlight]
    for (int i = 0; i < 10; i++) // [!code highlight]
    { // [!code highlight]
        p[i] = X + i; // [!code highlight]
    } // [!code highlight]
    printf("hello world \n"); // [!code highlight]
    return 0; // [!code highlight]
}
```

:::

::: warning 宏定义的变量

宏定义的变量是在预处理阶段展开的，所以在编译时，宏定义的变量会被替换为其对应的值。因此，宏定义的变量会隐含在只读数据段中。（也就是在编译时，宏定义的变量被使用的地方的宏变量名会被替换为其对应的值）

在本例中，所有使用到宏定义的变量 X 都会被替换为 1024。

:::

## 内存的分配与回收

以为用户进程分配的内存是否连续，内存的分配方式区分为连续分配管理方式和非连续分配管理方式。

### 连续分配管理方式

#### 单一连续分配

在单一连续分配方式中，内存被分为**系统区**和**用户区**。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。内存中**只能有一道用户程序**，用户程序独占整个用户区空间。

- 优点

  - 实现简单；
  - 无外部碎片；
  - 可以采用覆盖技术扩充内存：不一定需要采取内存保护（ eg: 早期的 PC 操作系统 MS-DOS ）

- 缺点

  - 只能用于单用户、单任务的操作系统中；
  - 有内部碎片；
  - 存储器利用率极低

::: tip 内部碎片

分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”

:::

#### 固定分区分配

20 世纪 60 年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个**用户空间**划分为**若干个固定大小的分区**，在**每个分区中只装入一道作业**，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式

固定分区分配又分为**分区大小相等**和**分区大小不等**

- 分区大小相等

  缺乏灵活性，但是很**适合用于用一台计算机控制多个相同对象的场合**（比如：钢铁厂有 n 个相同的炼钢炉，就可把内存分为 n 个大小相等的区域存放 n 个炼钢炉控制程序）

- 分区大小不等

  增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）

  操作系统需要建立一个数据结构——**分区说明表**，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的**大小、起始地址、状态(是否已分配)**{#blue-msg}

  类似于：

  | 分区号 | 分区大小（单位：KB） | 起始地址（单位：K） | 状态   |
  | ------ | -------------------- | ------------------- | ------ |
  | 1      | 2                    | 8                   | 未分配 |
  | 2      | 2                    | 10                  | 未分配 |
  | 3      | 4                    | 12                  | 已分配 |
  | ……     | ……                   | ……                  | ……     |

  当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”

  - 优点：实现简单，无外部碎片

  - 缺点：
    - 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能;
    - 会产生内部碎片，内存利用率低

#### 动态分区分配

**动态分区分配又称为可变分区分配**。这种分配方式**不会预先划分内存分区**，而是在进程装入内存时**根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg: 假设某计算机内存大小为 64 MB ，系统区 8 MB ，用户区共 56 MB ……）

具体实现可以采用空闲分区表或空闲分区链表来管理空闲分区。

- **空闲分区表**

每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息

- **空闲分区链表**

每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息

---

动态分区分配没有内部碎片，但是有外部碎片

**内部碎片**：分配给某进程的内存区域中，如果有些部分没有用上
**外部碎片**：是指内存中的某些空闲分区由于太小而难以利用

如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求

可以通过**紧凑（拼凑，Compaction）**{#blue-msg}技术来解决外部碎片。

##### 动态分区分配的算法

::: info 首次适应算法（First Fit）

- **算法思想**

  从内存的低地址开始，顺序查找空闲分区表，找到第一个能满足进程需求的分区，将之分配给进程，若进程大小大于该分区大小，则将该分区一分为二，将低地址部分分配给进程，高地址部分则作为新的空闲分区加入到空闲分区表中。若进程大小小于该分区大小，则将该分区全部分配给进程。

- **实现方式**

  **空闲分区以地址递增的次序排列**{#blue-msg}。每次分配内存时顺序查找**空闲分区链**{#blue-msg}（或**空闲分区表**{#blue-msg}），找到大小能满足要求的第一个空闲分区

:::

::: tip 最佳适应算法（Best Fit）

- **算法思想**

  由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区即，优先使用更小的空闲区

- **实现方式**

  空闲分区**按容量递增次序链接**{#blue-msg}。每次分配内存时顺序查找**空闲分区链**{#blue-msg}（或**空闲分区表**{#blue-msg}），找到大小能满足要求的第一个空闲分区

- **缺点**

  **每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片**{#red-msg}

:::

::: warning 最坏适应算法（Worst Fit）

又称**最大适应算法**{#blue-msg}(Largest Fit)

- **算法思想**

  为了解决最佳适应算法的问题--即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

- **实现方式**

  空闲分区**按容量递减次序链接**{#blue-msg}。每次分配内存时顺序查找**空闲分区链**{#blue-msg}（或**空闲分区表**{#blue-msg}），找到大小能满足要求的第一个空闲分区

- **缺点**

  **每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了**{#red-msg}

:::

::: caution 近邻适应算法（Next Fit）

- **算法思想**

  首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题

- **实现方式**

  空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时**从上次查找结束的位置**开始查找**空闲分区链**（或**空闲分区表**），找到大小能满足要求的第一个空闲分区。

- **优点**

  **首次适应算法每次都要从头查找，每次都需要检索低地址的小分区但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）**{#blue-msg}。

- **缺点**

  **邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）**{#red-msg}

:::

综合来看，四种算法中，**首次适应算法**{#red-msg}的效果反而更好

### 非连续分配管理方式

#### 基本分页存储管理方式 :thumbsup:

- **什么是分页存储**

将内存空间分为一个个**大小相等的分区**（比如：每个分区 4 KB ），每个分区就是一个“**页框**”（页框=页帧=内存块=物理块=物理页面）。每个页框有一个编号，即“**页框号**”（页框号=页帧号=内存块号=物理块号=物理页号），页框号**从 0 开始**{#red-msg}

将**进程的逻辑地址空间**也分为**与页框大小相等**的一个个部分，每个部分称为一个“**页**”或“**页面**”。每个页面也有一个编号：即“页号”，页号也是**从 0 开始**

操作系统**以页框为单位为各个进程分配内存空间**。进程的每个页面分别放入一个页框中。也就是说，**进程的页面**与**内存的页框**有一一对应的关系。
各个页面不必连续存放，可以放到不相邻的各个页框中

- **页表**

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张**页表**。注：页表通常存在 PCB （进程控制块）中

::: warning 注意

1. 一个进程对应一张页表

2. 进程的每个页面对应一个页表项

3. 每个**页表项**由“页号”和“块号”组成

4. 页表记录进程**页面**和实际存放的**内存块**之间的**映射关系**

5. 每个页表项的长度是相同的

:::

页表大概的数据结构如下：

| 页号 | 块号 |
| :--: | :--: |
|  0   |  3   |
|  1   |  6   |
|  2   |  4   |
| ...  | ...  |
|  n   |  8   |

::: tip 例子

假设某系统物理内存大小为 4 GB ，页面大小为 4 KB，则每个页表项至少应该为多少字节？

内存块大小 = 页面大小 = 4 KB= 2^12^ B

4 GB 的内存总共会被分为 2^32^ / 2^12^ = 2^20^ 个内存块

内存块号的范围应该是 0 ~ 2^20^ - 1

内存块号至少要用 20 bit 来表示

至少要用 3B 来表示块号（3 \* 8 = 24 bit）

由于页号是隐含的，因此每个页表项占 3B ，存储整个页表至少需要 3 \* (n+1) B

**计算机中内存块的数量 → 页表项中块号至少占多少字节**{#red-msg}

页表项连续存放，因此页号可以是隐含的，不占存储空间（类似数组）

:::

注意：页表记录的只是内存块号，而不是内存块的起始地址！ J 号内存块的起始地址 = J \* 内存块大小

- **地址转换的实现** :thumbsup:

特点：虽然进程的各个页面是离散存放的，但是页面内部是连续存放的

如果要访问逻辑地址 A ，则

1. 确定逻辑地址 A 对应的“页号” P
2. 找到 P 号页面在内存中的起始地址（需要查页表）
3. 确定逻辑地址 A 对应的“页内偏移量” W
4. 内存中实际的物理地址为：P 号页面对应的起始地址 + 页内偏移量 = P \* 内存块大小 + W

::: tip 例子

在某计算机系统中，页面大小是 50 B 。某进程逻辑地址空间大小为 200 B ，则逻辑地址 110 对应的页号、页内偏移量是多少？

**页号** = 逻辑地址 / 页面长度（取除法的**整数**部分）
**页内偏移量** = 逻辑地址 % 页面长度（取除法的**余数**部分）

**页号** = 110 / 50 = 2
**页内偏移量** = 110 % 50 = 10

逻辑地址 可以拆分为 **（页号，页内偏移量）**{#red-msg}
通过页号查询页表，可知页面在内存中的起始地址

页面在内存中的起始地址 + 页内偏移量 = 实际的物理地址

:::

在计算机内部，地址是用二进制表示的，如果**页面大小刚好是 2 的整数幂**{#blue-msg}，则计算机硬件可以很快速的把逻辑地址拆分成 **（页号，页内偏移量）**{#red-msg}

结论：如果每个页面大小为 **2^k^**{#red-msg}B，用二进制数表示逻辑地址，则**末尾 K 位**即为**页内偏移量**，其余部分就是**页号**

如果页面大小刚好是 2 的整数幂，则只需把页表中记录的**物理块号拼接上页内偏移量**就能得到对应的**物理地址**

对于此类情况，可以有更快速的方式计算页号和页内偏移量

::: danger 重要

如果有 K 位表示“页内偏移量”，则说明该系统中一个页面的大小是 2^k^ 个内存单元
如果有 M 位表示“页号”，则说明在该系统中，一个进程最多允许有 2^M^ 个页面

页面大小 <-> 页内偏移量位数 -> 逻辑地址结构

:::

##### 基本地址变换机构 :thumbsup:

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址

通常会在系统中设置一个页表寄存器（ PTR ），存放页表在内存中的起始地址 F 和页表长度 M 。进程未执行时，页表的始址和页表长度放在进程控制块（ PCB ）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中

操作系统读取进程物理内存的过程：

1. 根据逻辑地址计算出页号、页内偏移量
2. 判断页号是否越界
3. 查询页表，找到页号对应的页表项，确定页面存放的内存块号
4. 用内存块号和页内偏移量得到物理地址
5. 访问目标内存单元

::: tip 参考过程 :thumbsup:

设页面大小为 L （页面大小是 2 的整数幂），逻辑地址 A 到物理地址 E 的变换过程如下：

1. 计算页号 P 和页内偏移量 W （如果用十进制数手算，则 P = A / L ， W = A % L ；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）

2. 比较页号 P 和页表长度 M ，若 P **$\ge$** M ，则产生越界中断，否则继续执行。（注意：页号是从 0 开始的，而页表长度至少是 1 ，因此 **P = M 时也会越界**）

3. 页表中页号 P 对应的 **页表项地址 = 页表起始地址 F + 页号 P \* 页表项长度**{#red-msg}，取出该页表项内容 b 即为内存块号。（注意区分**页表项长度、页表长度、页面大小的区别**{#red-msg}。页表长度指的是这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；**页面大小**指的是一个页面占多大的存储空间）

4. 计算 E = b \* L + W，用得到的物理地址 E 去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）

:::

::: tip 例子

若**页面大小 L 为 1 K 字节**{#red-msg}，页号 2 对应的内存块号 b = 8 ，将逻辑地址 A = 2500 转换为物理地址 E 。等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占 10 位（与页面大小 L 相关，可以由此推出页面大小），页号 2 对应的内存块号 b = 8,将逻辑地址 A = 2500 转换为物理地址 E

1. 计算页号、页内偏移量
   **页号** = A / L = 2500 / 1024 = 2
   **页内偏移量** = A % L = 2500 % 1024 = 425
2. 检查页号是否越界
   页号 2 小于页表长度 8 ，因此不会越界
3. 查询页表，找到页号 2 对应的页表项，确定页面存放的内存块号
   页号 2 对应的页表项内容 b = 8
4. 计算物理地址 E = b \* L + W = 8 \* 1024 + 425 = 8644

:::

在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，**页式管理中地址是一维的**。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位

- **进一步讨论**

假设某系统物理内存大小为 4 GB ，页面大小为 4 KB，的内存总共会被分为 2^32^ / 2^12^ = 2^20^ 个内存块，因此内存块号的范围应该是 0 ~ 2^20^ - 1
因此至少要 20 个二进制位才能表示这么多的内存块号，因此至少要 3 个字节才够（每个字节 8 个二进制位， 3 个字节共 24 个二进制位）

各页表项会**按顺序连续地**存放在内存中
如果该页表在内存中存放的起始地址为 X ，则 M 号页对应的页表项是存放在内存地址为 X + 3 \* M （每个页表项占 3 个字节）

一个页面为 4 KB ，则每个页框可以存放 4096 / 3 = 1365 个页表项但是这个页框会剩余 4096 % 3 = 1B 页内碎片因此，1365 号页表项存放的地址为 X + 3 \* 1365 + **1** 如果**每个页表项占 4 字节**，则每个页框刚好可存放 1024 个页表项

1024 号页表项虽然是存放在下一个页框中的，但是它的地址依然可以用 X + 4 \* 1024 得出

理论上，页表项长度为 3B 即可表示内存块号的范围，但是，为了方便页表的查询常常会让一个页表项占更多的字节，使得**每个页面恰好可以装得下整数个页表项**{#blue-msg}

**页面偏移量位数 <-> 页面大小（能够掌握相互之间推导）**{#red-msg} :thumbsup:

**查询程序物理地址的过程中有两次访问内存，第一次为查找页表、第二次为访问目标内存单元**{#red-msg}

##### 具有快表的地址变换机构

- **快表（TLB）**

**快表**，又称**联想寄存器**(TLB，Translation Lookaside Buffer)，是一种**访问速度比内存快很多**的高速缓存(**TLB 不是内存！**)，用来存放**最近访问的页表项的副本**，可以加速地址变换的速度。与此对应，内存中的页表常称为**慢表**

::: tip 高速缓存过程

假设：访问 TLB 只需 1 us 访问内存需要 100 us

假设某进程执行过程中要依次访问 (0, 0) 、 (0, 4) 、 (0, 8) 这几个逻辑地址

![高速缓存过程](https://store.s1r0ko.top/svg/m/os/18/2_ver_1.svg)

若快表中没有目标页表项，则需要查询内存中的页表，最近使用过的页表项会放入快表

若快表命中就不需要再访问内存了

快表中存放的是页表的一部分副本（成本高、容量小）

- **具体步骤**

1. CPU 给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较

2. 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可

3. 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）

由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。
因为局部性原理，一般来说快表的命中率可以达到 90% 以上

**有的系统支持快表和慢表同时查找**{#red-msg}

:::

- **局部性原理**

  - **时间局部性**

  如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）

  - **空间局部性**

  一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）

  上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项

- **总结**

|                        | 地址变换过程                                                                                                                                                                                                                                                    |          访问一个逻辑地址的访存次数          |
| :--------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------: |
|    基本地址变换机构    | ① 算页号、页内偏移量 <br> ② 检查页号合法性 <br> ③ 查页表，找到页面存放的内存块号 <br> ④ 根据内存块号与页内偏移量得到物理地址 <br> ⑤ 访问目标内存单元                                                                                                            |                   两次访存                   |
| 具有快表的地址变换机构 | ① 算页号、页内偏移量 <br> ② 检查页号合法性 <br> ③ 查快表。若命中，即可知道页面存放的内存块号，可直接进行 ⑤ 若未命中则进行 ④ <br> ④ 查页表，找到页面存放的内存块号，并且将页表项复制到快表中 <br> ⑤ 根据内存块号与页内偏移量得到物理地址 <br> ⑥ 访问目标内存单元 | 一次访存（快表命中）或两次访存（快表未命中） |

TLB 和普通 Cache 的区别—— TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本

##### 两级页表

- 单极页表存在的问题

  - 问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框

  可将长长的页表进行分组，使每个内存块刚好可以放入一个分组（比如上个例子中，页面大小 4KB ，每个页表项 4B ，每个页面可存放 1K 个页表项，因此每 1K 个连续的页表项为一组，每组刚好占一个内存块，再讲各组离散地放到各个内存块中）另外，要为离散分配的页表再建立一张页表，称为**页目录表**{#red-msg}，或称**外层页表**{#blue-msg}，或称**顶层页表**{#blue-msg} :thumbsup:

  - 问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面

  可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存

:::: warning 需要注意的一些细节

1. 若采用多级页表机制，则各级页表的大小不能超过一个页面 :thumbsup:

::: tip 例子

某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB ，页表项大小为 4B ，假设采用纯页式存储，则要采用 ？ 级页表，页内偏移量为 ？ 位？

页面大小 = 4KB = 2^12^B ，按字节编址，因此页内偏移量为 12 位
页号 = 40 - 12 = 28 位
页面大小 = 2^12^B ，页表项大小 = 4B ，则每个页面可存放 2^12^ / 4 = 2^10^ 个页表项

因此各级页表最多包含 2^10^ 个页表项，需要 10 位二进制位才能映射到 2^10^ 个页表项，因此每一级的页表对应页号应为 10 位。总共 28 位的页号至少要分为三级

:::

2. 两级页表的访存次数分析（假设没有快表机构）

第一次访存：访问内存中的页目录表
第二次访存：访问内存中的二级页表
第三次访存：访问目标内存单元

N 级页表访问一个逻辑地址需要 N + 1 次访存

::::

#### 基本分段存储管理

与“分页”最大的区别就是——离散分配时所分配地址空间的基本单位不同

进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），**每段从 0 开始编址**{#red-msg}

内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。

- 分段系统的逻辑地址结构由段号（段名）和（段内地址段内偏移量）所组成。

  - 段号的位数决定了每个进程最多可以分几个段

  - 段内地址位数决定了每个段的最大长度是多少

- **段表**{#blue-msg}

程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”

段表的基本结构如下：

| 段号 | 段长 | 基址 |
| ---- | ---- | ---- |
| 0    | 7k   | 80k  |
| 1    | 5k   | 100k |
| 2    | 3k   | 150k |

1. 每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称“基址”）和段的长度

2. 各个段表项的长度是相同的。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号 16 位,段内地址 16 位），因此用 16 位即可表示最大段长。物理内存大小为 4GB （可用 32 位表示整个物理内存地址空间）。因此，可以让每个段表项占 16 + 32 = 48 位，即 6B 。由于段表项长度相同，因此**段号可以是隐含的，不占存储空间**{#red-msg}。若段表存放的起始地址为 M ，则 K 号段对应的段表项存放的地址为 M + K \* 6

分段表查询内存过程具体如下：

![分段表查询内存过程](//store.s1r0ko.top/svg/m/os/18/3_ver_1.svg)

1. 根据逻辑地址得到段号、段内地址

2. 判断段号是否越界,若 S ≥ M，则产生越界中断，否则继续执行

3. 查询段表，找到对应的段表项，段表项的存放地址为 F + S \* 段表项长度

4. 检查段内地址是否超过段长。若 W ≥ C，则产生越界中断，否则继续执行

5. 计算得到物理地址

6. 访问目标内存单元

::: tip 分段、分页管理的对比

**页**是**信息的物理单位**。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，**对用户是不可见的**
**段**是**信息的逻辑单位**。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。**分段对用户是可见的**，用户编程时需要显式地给出段名

页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序

**分页**的用户进程**地址空间是一维的**，程序员只需给出一个记忆符即可表示一个地址
**分段**的用户进程**地址空间是二维的**，程序员在标识一个地址时，既要给出段名，也要给出段内地址

**分段**比分页更容易实现信息的共享和保护

不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）

- 访问一个逻辑地址需要几次访存？

分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存
分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存

:::

与分页系统类似，分段系统中也**可以引入快表机构**{#red-msg}，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度

#### 段页式存储管理

- 两种不同管理方式的优缺点

|          | 优点                                                     | 缺点                                                                         |
| -------- | -------------------------------------------------------- | ---------------------------------------------------------------------------- |
| 分页管理 | 内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片 | 不方便按照逻辑模块实现信息的共享和保护                                       |
| 分段管理 | 很方便按照逻辑模块实现信息的共享和保护                   | 如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片 |

为了解决分页管理中会产生的外部碎片问题，引入了段页式存储管理

段页式存储的原理是将进程的地址空间按照段的方式进行划分，每个段再按照页的方式进行划分

其中段页式的逻辑地址结构为：（段号，页号，页内偏移量）

**段号的位数决定了每个进程最多可以分几个段**{#red-msg}
**页号位数决定了每个段最大有多少页**{#red-msg}
**页内偏移量决定了页面大小、内存块大小是多少**{#red-msg}

每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个段表项长度相等，段号是隐含的
每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的

- 段表结构（段号隐含）

| 段号 | 页表长度 | 页表存放块号 |
| ---- | -------- | ------------ |
| 0    | 7        | 80           |
| 1    | 5        | 100          |
| 2    | 3        | 150          |

- 页表结构（页号隐含）

| 页号 | 内存块号 |
| ---- | -------- |
| 0    | 80       |
| 1    | 81       |
| 2    | 82       |
| 3    | 83       |
| 4    | 84       |
| 5    | 85       |
| 6    | 86       |

读取内存流程如下：

![段页式存储管理读取内存流程](//store.s1r0ko.top/svg/m/os/18/4_ver_1.svg)

1. 根据逻辑地址得到段号、页号、页内偏移量

2. 判断段号是否越界：若 S ≥ M，则产生越界中断，否则继续执行

3. 查询段表，找到对应的段表项，段表项的存放地址为 F + S \* 段表项长度

4. 检查页号是否越界，若页号 ≥ 页表长度，则发生越界中断，否则继续执行

5. 根据页表存放块号、页号查询页表：找到对应页表项

6. 根据内存块号、页内偏移量得到最终的物理地址

7. 访问目标内存单元
