---
title: 内存
date: 2025-09-25
icon: 'gears'
order: 18
category: 
    - '408'
    - '操作系统'
    - 考研  
---

## 内存的基础知识 :thumbsup:

内存可存放数据。程序执行前需要先放到内存中才能被 CPU 处理——缓和 CPU 与硬盘之间的速度矛盾

内存地址从 0 开始，每个地址对应一个存储单元
内存中也有一个一个的“小房间”，每个小房间就是一个“存储单元”
如果计算机“按字节编址”则每个存储单元大小为 1 字节，即 1B ，即 8 个二进制位
如果字长为 16 位的计算机“按字编址”，则每个存储单元大小为 1 个字;每个字的大小为 16 个二进制位

## 一些数量单位

1 B = 8 位（bit）
1 KB = 1024 B = $2^{10}$ B
1 MB = 1024 KB = $2^{20}$ B
1 GB = 1024 MB = $2^{30}$ B
1 TB = 1024 GB = $2^{40}$ B

程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址），即:相对于进程的起始地址而言的地址

## 如何通过逻辑地址获取物理地址 :thumbsup:

主要有三种方式：

### 绝对装入

在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码

装入程序按照装入模块中的地址，将程序和数据装入内存

绝对装入**只适用于单道程序环境**{#red-msg}

### 可重定位装入（静态重定位）

又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）

一般是多道批处理程序使用

### 动态运行时装入（动态重定位）

静态重定位的特点是在一个作业装入内存时，**必须分配其要求的全部内存空间**{#red-msg}，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，**在运行期间就不能再移动**{#red-msg}，也不能再申请内存空间

又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行**{#red-msg}。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个**重定位寄存器**{#red-msg}的支持

::: tip 重定位寄存器的作用

存放装入模块存放的**起始位置**{#blue-msg}

:::

采用动态重定位时**允许程序在内存中发生移动**{#red-msg}，并且可将程序分配到不连续的存储区中;在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存;便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间

现代操作系统多使用动态运行时装入方式

## 从高级语言到程序 :thumbsup:

编译：将高级语言编写的程序转换为机器语言的程序（每个高级语言文件对应一个目标模块，通常为 `*.o` 的拓展名）

链接：将编译后的多个目标模块与所需的库函数链接起来，组装生成一个可执行文件（装入模块）

## 链接的三种方式 :thumbsup:

- **静态链接**

在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开

- **装入时动态链接**

将各目标模块装入内存时，边装入边链接的链接方式

- **运行时动态链接** :thumbsup:

在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享

## 内存管理

操作系统需要对实现以下四个功能以实现内存管理

1. **内存的分配与回收**

2. **对内存空间进行扩充**

操作系统需要提供某种技术从逻辑上对内存空间进行扩充

3. **地址转换（三种装入方式）**

为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况

4. **内存保护**

操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰

内存保护一般使用两种方法

- **设置一对上、下限寄存器**

在 CPU 中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时， CPU 检查是否越界

- **越界检查**

采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址

## 进程的内存映像

![内存映像模型](https://store.s1r0ko.top/svg/m/os/18/1_ver_1.svg)

假设此时有一段这样的 C 语言代码

```c
#include <stdio.h>
#define X 1024 // 定义一个宏 X，值为 1024
int a = 1; // 全局变量 a，值为 1
const int b = 2; // 全局常量 b，值为 2
int main() 
{
    static int c = 3; // 静态局部变量 c，值为 3
    int d = 4; // 局部变量 d，值为 4
    int *p = (int *)malloc(sizeof(int) * 10); // 动态分配内存，p 指向该内存
    a = b + c + d; // a = 2 + 3 + 4 = 9
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```
那么不同部分位于的内存区域如下

- **操作系统内核区**

进程控制块 PCB 等数据

- **栈区**

在函数大括号内定义的局部变量、函数调用时传入的参数

- **堆区**

动态分配的内存（如 malloc 函数申请和 free 释放的内存）存储在堆区

- **共享库的存储映射区**

被调用的库函数的代码和数据存储在共享库的存储映射区

- **读写数据**

定义在函数外的全局变量、由 static 关键字修饰的变量

- **只读代码/数据段**

程序代码、由 const 关键字修饰的变量

::: code-tabs

@tab 栈

```c
#include <stdio.h>
#define X 1024 
int a = 1; 
const int b = 2; 
int main() 
{
    static int c = 3; 
    int d = 4; // [!code highlight]
    int *p = (int *)malloc(sizeof(int) * 10); // 等号前面的部分 [!code highlight] 
    a = b + c + d; 
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 共享库的存储映射区

```c
#include <stdio.h> // [!code highlight]
#define X 1024 
int a = 1; 
const int b = 2; 
int main() 
{
    static int c = 3; 
    int d = 4; 
    int *p = (int *)malloc(sizeof(int) * 10); 
    a = b + c + d; 
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 堆

```c
#include <stdio.h>
#define X 1024 
int a = 1; 
const int b = 2; 
int main() 
{
    static int c = 3; 
    int d = 4; 
    int *p = (int *)malloc(sizeof(int) * 10); // malloc 开辟的内存 [!code highlight] 
    a = b + c + d; 
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 读写数据段

```c
#include <stdio.h>
#define X 1024 
int a = 1; // [!code highlight]
const int b = 2; 
int main() 
{
    static int c = 3; // [!code highlight]
    int d = 4; 
    int *p = (int *)malloc(sizeof(int) * 10); 
    a = b + c + d; 
    for (int i = 0; i < 10; i++)
    {
        p[i] = X + i;
    }
    printf("hello world \n");
    return 0;
}
```

@tab 只读代码/数据段

```c 
#include <stdio.h>
#define X 1024 
int a = 1; 
const int b = 2; // [!code highlight]
int main() 
{
    static int c = 3; 
    int d = 4; 
    int *p = (int *)malloc(sizeof(int) * 10); 
    a = b + c + d; // [!code highlight]
    for (int i = 0; i < 10; i++) // [!code highlight]
    { // [!code highlight]
        p[i] = X + i; // [!code highlight]
    } // [!code highlight]
    printf("hello world \n"); // [!code highlight]
    return 0; // [!code highlight]
}
```

:::

::: warning 宏定义的变量

宏定义的变量是在预处理阶段展开的，所以在编译时，宏定义的变量会被替换为其对应的值。因此，宏定义的变量会隐含在只读数据段中。（也就是在编译时，宏定义的变量被使用的地方的宏变量名会被替换为其对应的值）

在本例中，所有使用到宏定义的变量 X 都会被替换为 1024。

:::

## 内存的分配与回收

以为用户进程分配的内存是否连续，内存的分配方式区分为连续分配管理方式和非连续分配管理方式。

### 连续分配管理方式

#### 单一连续分配

在单一连续分配方式中，内存被分为**系统区**和**用户区**。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。内存中**只能有一道用户程序**，用户程序独占整个用户区空间。

- 优点
    - 实现简单；
    - 无外部碎片；
    - 可以采用覆盖技术扩充内存：不一定需要采取内存保护（ eg: 早期的PC操作系统 MS-DOS ）

- 缺点

    - 只能用于单用户、单任务的操作系统中；
    - 有内部碎片；
    - 存储器利用率极低

::: tip 内部碎片

分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”

:::

#### 固定分区分配

20 世纪 60 年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个**用户空间**划分为**若干个固定大小的分区**，在**每个分区中只装入一道作业**，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式

固定分区分配又分为**分区大小相等**和**分区大小不等**

- 分区大小相等

    缺乏灵活性，但是很**适合用于用一台计算机控制多个相同对象的场合**（比如：钢铁厂有 n 个相同的炼钢炉，就可把内存分为 n 个大小相等的区域存放 n 个炼钢炉控制程序）

- 分区大小不等

    增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）

    操作系统需要建立一个数据结构——**分区说明表**，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的**大小、起始地址、状态(是否已分配)**{#blue-msg}

    类似于：

    | 分区号 | 分区大小（单位：KB） | 起始地址（单位：K） | 状态 |
    | --- | -------- | -------- | ---- |
    | 1 | 2 | 8 | 未分配 |
    | 2 | 2 | 10 | 未分配 |
    | 3 | 4 | 12 | 已分配 |
    | …… | …… | …… | …… |

    当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”

    - 优点：实现简单，无外部碎片

    - 缺点：
        - 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能;
        - 会产生内部碎片，内存利用率低

#### 动态分区分配

**动态分区分配又称为可变分区分配**。这种分配方式**不会预先划分内存分区**，而是在进程装入内存时**根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg: 假设某计算机内存大小为 64 MB ，系统区 8 MB ，用户区共 56 MB ……）

具体实现可以采用空闲分区表或空闲分区链表来管理空闲分区。

- **空闲分区表**

每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息

- **空闲分区链表**

每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息

---

动态分区分配没有内部碎片，但是有外部碎片

**内部碎片**：分配给某进程的内存区域中，如果有些部分没有用上
**外部碎片**：是指内存中的某些空闲分区由于太小而难以利用

如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求

可以通过**紧凑（拼凑，Compaction）**{#blue-msg}技术来解决外部碎片。

##### 动态分区分配的算法

::: info 首次适应算法（First Fit）

- **算法思想**

    从内存的低地址开始，顺序查找空闲分区表，找到第一个能满足进程需求的分区，将之分配给进程，若进程大小大于该分区大小，则将该分区一分为二，将低地址部分分配给进程，高地址部分则作为新的空闲分区加入到空闲分区表中。若进程大小小于该分区大小，则将该分区全部分配给进程。

- **实现方式**

    **空闲分区以地址递增的次序排列**{#blue-msg}。每次分配内存时顺序查找**空闲分区链**{#blue-msg}（或**空闲分区表**{#blue-msg}），找到大小能满足要求的第一个空闲分区

:::

::: tip 最佳适应算法（Best Fit）

- **算法思想**

    由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区即，优先使用更小的空闲区

- **实现方式**

    空闲分区**按容量递增次序链接**{#blue-msg}。每次分配内存时顺序查找**空闲分区链**{#blue-msg}（或**空闲分区表**{#blue-msg}），找到大小能满足要求的第一个空闲分区

- **缺点**

    **每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片**{#red-msg}

:::

::: warning 最坏适应算法（Worst Fit）

又称**最大适应算法**{#blue-msg}(Largest Fit)

- **算法思想**

    为了解决最佳适应算法的问题--即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

- **实现方式**

    空闲分区**按容量递减次序链接**{#blue-msg}。每次分配内存时顺序查找**空闲分区链**{#blue-msg}（或**空闲分区表**{#blue-msg}），找到大小能满足要求的第一个空闲分区

- **缺点**

    **每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了**{#red-msg}

:::

::: caution 近邻适应算法（Next Fit）

- **算法思想**

    首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题

- **实现方式**

    空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时**从上次查找结束的位置**开始查找**空闲分区链**（或**空闲分区表**），找到大小能满足要求的第一个空闲分区。

- **优点**

    **首次适应算法每次都要从头查找，每次都需要检索低地址的小分区但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）**{#blue-msg}。

- **缺点**

    **邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）**{#red-msg}

:::

综合来看，四种算法中，**首次适应算法**{#red-msg}的效果反而更好

### 非连续分配管理方式

#### 基本分页存储管理方式 :thumbsup:

- **什么是分页存储**

将内存空间分为一个个**大小相等的分区**（比如：每个分区 4 KB ），每个分区就是一个“**页框**”（页框=页帧=内存块=物理块=物理页面）。每个页框有一个编号，即“**页框号**”（页框号=页帧号=内存块号=物理块号=物理页号），页框号**从 0 开始**{#red-msg}

将**进程的逻辑地址空间**也分为**与页框大小相等**的一个个部分，每个部分称为一个“**页**”或“**页面**”。每个页面也有一个编号：即“页号”，页号也是**从 0 开始**

操作系统**以页框为单位为各个进程分配内存空间**。进程的每个页面分别放入一个页框中。也就是说，**进程的页面**与**内存的页框**有一一对应的关系。
各个页面不必连续存放，可以放到不相邻的各个页框中

- **页表**

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张**页表**。注：页表通常存在 PCB （进程控制块）中

::: warning 注意

1. 一个进程对应一张页表

2. 进程的每个页面对应一个页表项

3. 每个**页表项**由“页号”和“块号”组成

4. 页表记录进程**页面**和实际存放的**内存块**之间的**映射关系**

5. 每个页表项的长度是相同的

:::

页表大概的数据结构如下：

| 页号 | 块号 |
| :--: | :--: |
| 0 | 3 |
| 1 | 6 |
| 2 | 4 |
| ... | ... |
| n | 8 |

::: tip 例子

假设某系统物理内存大小为 4 GB ，页面大小为 4 KB，则每个页表项至少应该为多少字节？

内存块大小 = 页面大小 = 4 KB= 2^12^ B

4 GB 的内存总共会被分为 2^32^ / 2^12^ = 2^20^ 个内存块

内存块号的范围应该是 0 ~ 2^20^ - 1

内存块号至少要用 20 bit 来表示

至少要用 3B 来表示块号（3 * 8 = 24 bit）

由于页号是隐含的，因此每个页表项占 3B ，存储整个页表至少需要 3 * (n+1) B

**计算机中内存块的数量 → 页表项中块号至少占多少字节**{#red-msg}

页表项连续存放，因此页号可以是隐含的，不占存储空间（类似数组）

:::

注意：页表记录的只是内存块号，而不是内存块的起始地址！ J 号内存块的起始地址 = J * 内存块大小

- **地址转换的实现** :thumbsup:

特点：虽然进程的各个页面是离散存放的，但是页面内部是连续存放的

如果要访问逻辑地址 A ，则

1. 确定逻辑地址 A 对应的“页号” P
2. 找到 P 号页面在内存中的起始地址（需要查页表）
3. 确定逻辑地址 A 对应的“页内偏移量” W
4. 内存中实际的物理地址为：P 号页面对应的起始地址 + 页内偏移量 = P * 内存块大小 + W

::: tip 例子

在某计算机系统中，页面大小是 50 B 。某进程逻辑地址空间大小为 200 B ，则逻辑地址 110 对应的页号、页内偏移量是多少？

**页号** = 逻辑地址 / 页面长度（取除法的**整数**部分）
**页内偏移量** = 逻辑地址 % 页面长度（取除法的**余数**部分）

**页号** = 110 / 50 = 2
**页内偏移量** = 110 % 50 = 10

逻辑地址 可以拆分为 **（页号，页内偏移量）**{#red-msg}
通过页号查询页表，可知页面在内存中的起始地址

页面在内存中的起始地址 + 页内偏移量 = 实际的物理地址

:::

在计算机内部，地址是用二进制表示的，如果**页面大小刚好是 2 的整数幂**{#blue-msg}，则计算机硬件可以很快速的把逻辑地址拆分成 **（页号，页内偏移量）**{#red-msg}

结论：如果每个页面大小为 **2^k^**{#red-msg}B，用二进制数表示逻辑地址，则**末尾 K 位**即为**页内偏移量**，其余部分就是**页号**

如果页面大小刚好是 2 的整数幂，则只需把页表中记录的**物理块号拼接上页内偏移量**就能得到对应的**物理地址**

对于此类情况，可以有更快速的方式计算页号和页内偏移量

::: danger 重要

如果有 K 位表示“页内偏移量”，则说明该系统中一个页面的大小是 2^k^ 个内存单元
如果有 M 位表示“页号”，则说明在该系统中，一个进程最多允许有 2^M^ 个页面

页面大小 <-> 页内偏移量位数 -> 逻辑地址结构

:::

##### 基本地址变换机构 :thumbsup:

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址

通常会在系统中设置一个页表寄存器（ PTR ），存放页表在内存中的起始地址 F 和页表长度 M 。进程未执行时，页表的始址和页表长度放在进程控制块（ PCB ）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中

操作系统读取进程物理内存的过程：

1. 根据逻辑地址计算出页号、页内偏移量
2. 判断页号是否越界
3. 查询页表，找到页号对应的页表项，确定页面存放的内存块号
4. 用内存块号和页内偏移量得到物理地址
5. 访问目标内存单元

::: tip 参考过程

设页面大小为 L （页面大小是 2 的整数幂），逻辑地址 A 到物理地址 E 的变换过程如下：

1. 计算页号 P 和页内偏移量 W （如果用十进制数手算，则 P = A / L ， W = A % L ；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）

2. 比较页号 P 和页表长度 M ，若 P **$\ge$** M ，则产生越界中断，否则继续执行。（注意：页号是从 0 开始的，而页表长度至少是 1 ，因此 **P = M 时也会越界**）

3. 页表中页号 P 对应的 **页表项地址 = 页表起始地址 F + 页号 P * 页表项长度**{#red-msg}，取出该页表项内容 b 即为内存块号。（注意区分**页表项长度、页表长度、页面大小的区别**{#red-msg}。页表长度指的是这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；**页面大小**指的是一个页面占多大的存储空间）

4. 计算 E = b * L + W，用得到的物理地址 E 去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）

:::

::: tip 例子



:::