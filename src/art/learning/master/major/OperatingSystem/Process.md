---
title: 进程
date: 2025-08-18
icon: 'gears'
order: 10
category: 
    - '408'
    - '操作系统'
    - 考研  
---

## 进程的概念

程序：是**静态的**，就是个存放在磁盘里的可执行文件，就是一系列的指令集合

进程（ Process ）：是**动态的**，是程序的一次执行过程，同一个程序多次执行会对应多个进程

## 进程的组成——进程控制块（ PCB ）

当进程被创建时，操作系统会为该进程分配一个**唯一的**、**不重复的**“身份证号”-- **PID**{#red-msg} （Process ID ，进程 ID ）

包括 PID 、进程状态、进程优先级、进程控制信息、进程资源信息等将保存在一个称为 PCB （ Process Control Block ） 的数据结构中

所有操作系统需要使用的，**用于管理进程的信息，都保存在 PCB 中**{#red-msg}

PCB 是进程存在的唯一标志，当进程被创建时，操作系统为其创建 PCB ，当进程结束时，会回收其 PCB

## 进程的组成——程序段

PCB 部分是操作系统使用的，用于管理进程的信息，而程序段和数据段是进程使用的

程序的运行过程：

1. 源代码编译完成的可执行文件存在硬盘中 （ Windows 中为 .exe 后缀的文件）

2. 运行前将可执行文件加载到内存中，其中将开辟三个空间分别是 PCB 、程序段和数据段
程序段包含所有的指令，数据段包含运行中所需要的数据（包括源代码中显式声明的变量），操作系统则会在 PCB 中创建对应的 PID 等信息并初始化

3. 操作系统会为进程分配 CPU 时间片，进程会按照时间片的大小，轮流使用 CPU 执行指令

……

一个**进程实体（进程映像）**由 PCB 、程序段、数据段组成：进程是**动态的**，进程实体（进程映像）是**静态的**。

**程序段、数据段、 PCB**{#red-msg} 三部分组成了**进程实体**（**进程映像**）
引入进程实体的概念后，可把进程定义为：
**进程**是进程实体的**运行过程**{#blue-msg}，是系统进行**资源分配**{#red-msg}和**调度**{#red-msg}的一个独立单位

**注意：PCB是进程存在的唯一标志！**{#red-msg}

## 进程的特征

程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：

- 动态性

进程是程序的一次执行过程，是动态地产生、变化和消亡的

**动态性是进程最基本的特征**{#blue-msg}

- 并发性

内存中有多个进程实体，各进程可并发执行

- 独立性

进程是能独立运行、**独立获得资源、独立接受调度**的基本单位

- 异步性

各进程按各自独立的、不可预知的速度向前推进操作系统要提供“进程同步机制”来解决异步问题

- 结构性

每个进程都会配置一个 PCB ，结构上看，进程由程序段、数据段、 PCB 组成

上述特征仅要求理解，不需要逐字记忆

## 进程的状态

### 创建态

进程正在被创建时，它的状态是“**创建态**{#blue-msg}”，在这个阶段操作系统会为进程分配资源、初始化 PCB

### 就绪态

当进程创建完成后，便进入“**就绪态**{#blue-msg}”处于就绪态的进程已经具备运行条件，但由于没有空闲 CPU ，就暂时不能运行

### 运行态

如果一个进程此时在 CPU 上运行，那么这个进程处于“**运行态**{#blue-msg}”。CPU会执行该进程对应的程序（执行指令序列）

系统中可能会有很多个进程都处于就绪态，当 CPU 空闲时，操作系统就会选择一个就绪进程，让它上处理机运行

### 阻塞态

在进程运行的过程中，可能会请求**等待某个事件的发生**{#red-msg}（如等待某种系统资源的分配，或者等待其他进程的响应），在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下 CPU ，并让它进入“**阻塞态**{#blue-msg}”

当 CPU 空闲时，又会选择另一个“**就绪态**{#blue-msg}”进程上 CPU 运行

当**等待的事件**{#red-msg}发生时，进程从“**阻塞态**{#blue-msg}”回到“**就绪态**{#blue-msg}”

### 终止态

一个进程可以执行 exit 系统调用，请求操作系统终止该进程此时该进程会进入“**终止态**{#blue-msg}”，操作系统会让该进程下 CPU ，并回收内存空间等资源，最后还要回收该进程的 PCB

当终止进程的工作完成之后，这个进程就彻底消失了

## 进程状态的转换

![进程的转换](//store.s1r0ko.top/svg/m/os/10/1_ver_1.svg)

- 阻塞态→就绪态不是进程自身能控制的，是一种**被动行为**

- 运行态→阻塞态是一种进程自身做出的**主动行为**

::: warning 

**不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态**{#red-msg}（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）

:::


