---
title: 进程同步互斥相关问题
date: 2025-09-05
icon: 'gears'
order: 15
category: 
    - '408'
    - '操作系统'
    - 考研  
---

## 生产者-消费者问题

- **问题描述**

系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）

生产者、消费者共享一个**初始为空、大小为 n 的缓冲区**

只有**缓冲区没满**时，生产者才能把产品放入缓冲区，否则必须等待（缓冲区没满→生产者生产）
只有**缓冲区不空**时，消费者才能从中取出产品，否则必须等待（缓冲区没空→消费者消费）

缓冲区是临界资源，各进程必须**互斥地访问**

::: tip PV 操作题目分析步骤

1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系
2. 整理思路。根据各进程的操作流程确定 P 、 V 操作的大致顺序
3. 设置信号量。并根据题目条件确定信号量初值。（互斥信号量初值一般为 1 ，同步信号量的初始值要看对应资源的初始值是多少）

:::

根据问题描述，可以得出以下关系：

有产品（缓冲区未空） V → full → P 消费者消费

生产者生产 P ← empty ← V 缓冲区没满

```c title='信号量声明'
semaphore mutex = 1; // 互斥信号量,实现对缓冲区的互斥访问
semaphore empty = n; // 同步信号量,表示空闲缓冲区的数量
semaphore full = 0; // 同步信号量，表示产品的数量，也即非空缓冲区的数量
```

::: code-tabs

@tab 生产者

```c
producer() {
    while(1) {
        生产一个产品;
        P(empty); // 消耗一个空闲缓冲区
        P(mutex); // 实现互斥是在同一进程中进行一对PV操作
        把产品放入缓冲区;
        V(mutex);
        V(full); // 增加一个产品，实现两进程的同步关系，是在其中一个进程中执行 P 操作，在另一个进程中执行 V 操作
    }
}
```

@tab 消费者

```c
consumer() {
    while(1) {
        P(full); // 消耗一个产品（非空缓冲区）
        P(mutex);
        从缓冲区取出一个产品;
        V(mutex);
        V(empty); // 增加一个空闲缓冲区
        使用产品;
    }
}
```

:::

:::: warning

**实现互斥的 P 操作一定要在实现同步的 P 操作之后**{#red-msg}，因为：

两者 P 操作调换变成如下情况时，会导致死锁：

::: code-tabs

@tab 生产者

```c
producer() {
    while(1) {
        生产一个产品;
        P(empty); // [!code --] 
        P(mutex); // [!code --] 
        P(mutex); // [!code ++] ①
        P(empty); // [!code ++] ②
        把产品放入缓冲区;
        V(mutex);
        V(full); 
    }
}
```

@tab 消费者

```c
consumer() {
    while(1) {
        P(full); // [!code --] 
        P(mutex); // [!code --]
        P(mutex); // [!code ++] ③
        P(full);  // [!code ++] ④
        从缓冲区取出一个产品;
        V(mutex);
        V(empty); 
        使用产品;
    }
}
```

:::

若此时缓冲区内已经放满产品，则 `empty = 0` ，`full = n`

则生产者进程执行 ① 使 `mutex` 变为 0 ，再执行 ② ，由于已没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。
消费者进程执行 ③ ，由于 `mutex` 为 0 ，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。
这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“**死锁**”同样的，若缓冲区中没有产品，即 `full = 0` ， `empty = n` 。

按 ③④① 的顺序执行就会发生死锁。

**V 操作不会导致进程阻塞，因此两个 V 操作顺序可以交换**{#red-msg}

::::

- **总结**

生产者消费者问题是一个互斥、同步的综合问题

对于初学者来说最难的是发现题目中隐含的两对同步关系

有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费

这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量

![生产者消费者问题同步关系图](//store.s1r0ko.top/svg/m/os/14/2_ver_1.svg)

**实现“一前一后”需要“前 V 后 P ”**{#red-msg}

**易错点**：实现互斥和实现同步的两个 P 操作的先后顺序（死锁问题）

## 多生产者-多消费者问题

- **问题描述**

桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用 PV 操作实现上述过程。

可以看成以下对应关系：

**盘子**：**大小为 1 ，初始大小为空的缓冲区**{#blue-msg}

**爸爸**：**生产者进程 1**{#blue-msg}

**妈妈**：**生产者进程 2**{#blue-msg}

**女儿**：**消费者进程 1**{#blue-msg}

**儿子**：**消费者进程 2**{#blue-msg}

- **问题分析**

    - 关系分析

        - 互斥关系

        对缓冲区（盘子）的访问要互斥地进行

        - 同步关系

        1. 父亲将苹果放入盘子后，女儿才能取苹果
        2. 母亲将橘子放入盘子后，儿子才能取橘子
        3. 只有盘子为空时，父亲或母亲才能放入水果（“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果）

    - 整理思路

    ![多生产者-多消费者问题各进程关系](//store.s1r0ko.top/svg/m/os/14/3_ver_1.svg)

    - 设置信号量

    1. 同步信号量：

        - apple 初始为 0

        - orange 初始为 0

        - plate 初始为 n ，表示盘子还能存放多少水果

    2. 互斥信号量：

        - mutex 初始为 1

- **代码实现**

```c title='信号量声明'
semaphore mutex = 1; // 实现互斥访问盘子（缓冲区）
semaphore apple = 0; // 盘子中有几个苹果
semaphore orange = 0; // 盘子中有几个橘子
semaphore plate = 1; // 盘子中还可以放多少个水果
```

::: code-tabs

@tab PP1

```c
producer1() {
    while(1) {
        生产一个苹果;
        P(plate);
        P(mutex);
        把苹果放入盘子;
        V(mutex);
        V(apple);
    }
}
```

@tab PP2

```c
producer2() {
    while(1) {
        生产一个橘子;
        P(plate);
        P(mutex);
        把橘子放入盘子;
        V(mutex);
        V(orange);
    }
}
```

@tab CP1

```c
consumer1() {
    while(1) {
        P(apple);
        P(mutex);
        从盘子中取出一个苹果;
        V(mutex);
        V(plate);
        使用苹果;
    }
}
```

@tab CP2

```c
consumer2() {
    while(1) {
        P(orange);
        P(mutex);
        从盘子中取出一个橘子;
        V(mutex);
        V(plate);
        使用橘子;
    }
}
```

:::

::: tip 可不可以不用互斥信号量（ mutex ）？

- 分析：

刚开始， `CP1` 、 `CP2` 进程即使上处理机运行也会被阻塞。如果刚开始是 `PP1` 进程先上处理机运行，则：
`PP1` 执行 `P(plate)` ，可以访问盘子 → `PP2` 执行 `P(plate)` ，阻塞等待盘子 → `PP1` 放入苹果后执行 `V(apple)` ， `CP1` 进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源（盘子） → `CP1` 执行 `P(apple)` ，访问盘子， `V(plate)` ，等待盘子的 `PP2` 进程被唤醒 → `PP2` 进程访问盘子（其他进程暂时都无法进入临界区） → ……

- 结论：

即使不设置专门的互斥变量 `mutex` ，也不会出现多个进程同时访问盘子的现象

原因在于：本题中的缓冲区大小为 1 ，在任何时刻， apple 、 orange 、 plate 三个同步信号量中最多只有一个是 1 。因此在任何时刻最多只有一个进程的 P 操作不会被阻塞，并顺利地进入临界区
但是如果缓冲区大小大于 1 ，就会出现多个进程同时访问盘子的现象，可能会导致数据覆盖丢失的问题

:::

- **总结**

1. 在生产者-消费者问题中，如果缓冲区大小为 1 ，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析

2. “多生产者-多消费者问题”的关键在于理清复杂的同步关系。在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系

比如，如果从单个进程行为的角度来考虑的话，我们会有以下结论：
如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果
如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果
这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系了？

正确的分析方法应该从“**事件**{#red-msg}”的角度来考虑，我们可以把上述四对“进程行为的前后关系”抽象为一对“事件的前后关系”：

盘子变空事件 → 放入水果事件

“盘子变空事件”既可由儿子引发，也可由女儿引发；“放水果事件既可能是父亲执行，也可能是母亲执行。这样的话，就可以用一个同步信号量解决问题了

## 读者-写者问题

- **问题描述**

有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：
① 允许多个读者可以同时对文件执行读操作
② 只允许一个写者往文件中写信息
③ 任一写者在完成写操作之前不允许其他读者或写者工作（如果他同时读写可能导致数据不一致）
④ 写者执行写操作前，应让已有的读者和写者全部退出

::: tip 为什么允许同时存在多个对同一文件的读操作？

与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。因此多个读者可同时访问共享数据

:::

- **问题分析**

    - 关系分析

        - 两类进程

        1. 写进程
        2. 读进程

        - 互斥关系

        1. 写进程——写进程
        2. 写进程——读进程
        3. 读进程与读进程不存在互斥问题

    - 设置信号量

    1. 互斥信号量， rw 初始为 1 
    2. 互斥信号量， mutex 初始为 1 

- **代码实现**

```c title='信号量声明'
semaphore rw = 1; // 用于实现对共享文件的互斥访问
int count = 0; // 记录当前有几个读进程在访问文件
semaphore mutex = 1; // 用于保证对 count 变量的互斥访问
```

::: code-tabs

@tab 写进程

```c
writer() {
    while (1) {
        P(rw); // 写进程之前加锁
        写文件...
        V(rw); // 写进程之后解锁
    }
}
```

@tab 读进程

```c
reader() {
    while (1) {
        P(mutex); // 各读进程互斥访问 count 
        if (count == 0) { // 由第一个读进程负责
            P(rw); // 读之前“加锁”
        }
        count++; // 访问文件的读进程数 +1
        V(mutex);
        读文件...
        P(mutex); // 各读进程互斥访问 count
        count--; // 访问文件的读进程数 -1
        if (count == 0) { // 由最后一个读进程负责
            V(rw); // 读完了“解锁”
        }
        V(mutex);
    }
}
```

:::

::: warning 未设置 mutex 的情况

若两个读进程并发执行，则 `count = 0` 时两个进程也许都能满足 if 条件，都会执行 `P(rw)` ，从而使第二个读进程阻塞的情况。

如何解决：出现上述问题的原因在于对 `count` 变量的检查和赋值无法一气呵成，因此需要设置一个互斥信号量（ `mutex` ）来保证各读进程对 `count` 的访问是互斥的

:::

:::: warning 潜在的问题

只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的

为了解决这个问题需要设置一个写优先信号量（ `wrt` ），初始值为 1 

此时的代码实现为：

```c title='信号量声明'
semaphore wrt = 1; // 用于实现写优先
semaphore rw = 1; // 用于实现对共享文件的互斥访问
int count = 0; // 记录当前有几个读进程在访问文件
semaphore mutex = 1; // 用于保证对 count 变量的互斥访问
```

::: code-tabs

@tab 写进程

```c
writer() {
    while (1) {
        P(wrt); // 写进程之前加锁
        P(rw); // 写进程之前加锁
        写文件...
        V(rw); // 写进程之后解锁
        V(wrt); // 写进程之后解锁
    }
}
```

@tab 读进程

```c
reader() {
    while (1) {
        P(wrt); // 读进程之前加锁
        P(mutex); // 各读进程互斥访问 count 
        if (count == 0) { // 由第一个读进程负责
            P(rw); // 读之前“加锁”
        }
        count++; // 访问文件的读进程数 +1
        V(mutex);
        V(wrt); // 读进程之后解锁
        读文件...
        P(mutex); // 各读进程互斥访问 count
        count--; // 访问文件的读进程数 -1
        if (count == 0) { // 由最后一个读进程负责
            V(rw); // 读完了“解锁”
        }
        V(mutex);
    }
}
```

:::

思考以下情况：

1. 读进程 1 和读进程 2 同时访问

2. 写进程 1 和写进程 2 同时访问

3. 写进程 1 先访问，读进程 1 再访问

4. 读进程 1 先访问，写进程 1 再访问，最后读进程 2 访问

5. 写进程 1 先访问，读进程 1 再访问，最后写进程 2 访问

（对于互斥信号量的唤醒顺序取决于被阻塞时所处在的对应信号量的阻塞队列中的顺序，先阻塞的先被唤醒，详见[记录型信号量](#记录型信号量)）

::::

- **总结**

在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；
写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先，来先服务原则
有的书上把这种算法称为“读写公平法”

读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路
其核心思想在于设置了一个计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用 count 的值来判断当前进入的进程是否是 第一个/最后一个 读进程，从而做出不同的处理
另外，对 count 变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量
最后，还要认真体会我们是如何解决“写进程饥饿”问题的

绝大多数的考研 PV 操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决，如果遇到更复杂的问题，可以想想能否用读者写者问题的这几个思想来解决
