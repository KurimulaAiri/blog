---
title: 算法
icon: 'database'
category:
    - '数据结构'
    - '408'
    - 考研
tag:
    - c++
    - c
---
## 算法的基本概念

程序 = 数据结构 + 算法

**数据结构**解决如何正确地描述现实世界的问题，并存入计算机

**算法**则关注如何高效的处理这些数据以解决实际问题（求解问题的步骤）

## 算法的定义

算法是对特定问题求解步骤的一种描述，他是指令的有限序列，其中的每条指令表示一个或多个操作

## 算法的特性
### 有穷性

一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成

算法必须有穷，程序可以是无穷的

### 确定性

算法中的每条指令必须具有明确的含意，对于**相同的输入**只能得出**相同的输出**

### 可行性

算法中描述的操作都可以通过已经实现的**基本运算执行有限次**来实现

### 输入

一个算法**有零个或多个输入**，这些输入取自于某个特定的数据对象的集合

### 输出

一个算法**有一个或多个输出**，这些输出是与输入有着某种特定关系的量

## “好”的算法需要具备的特质

### 正确性

能够正确地解决问题

### 可读性

能够有良好的可读性，以便帮助人们理解（写代码有注释）

### 健壮性

输入非法输入时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果

### 高效率和低存储量需求

花的时间少，不费内存，空间复杂度低

## 算法的时间复杂度

事前预估算法的时间开销 $T(n)$ 与问题规模 $n$ 的关系 ( $T$ 表示 $time$ )

比如下面这一段示例代码

```c
void LoveYou(int n) { // n 为问题规模
    int i; // 起始数
    while (i <= n) { // 执行 3001 次
        i++; // 执行 3000 次
        printf("I Love You %d\n", i); // 执行 3000 次
    }
    printf("I Love More Then %d\n", n); // 执行一次
}

int main () {
    LoveYou(3000);
}
```



由此可得该程序的时间复杂度  $ T(3000) = 1 + 3001 + 2 * 3000 + 1 $ 

使用时间开销与问题规模 $ n $ 之间的关系则可以表达为 $ T(n) = 3n + 3 $ 



## 简化时间开销与问题规模间的关系

由于在代码过于复杂的情况下，清楚的写出如上面表达式的时间复杂度表达式过于困难，因此需要某些手段简化这一表达

我们可以使用时间复杂度的数量级 $ O(n) $ 来表示时间复杂度，即当 $ n $ 趋近于无限时，表达式中数量级较大的那一项可以约等于总数，而小的那几项可以直接抛弃掉，只留下最大数量级的项 ，严谨数学表达为：
$$
T(n) = O\big(f(n)\big) \Leftrightarrow \lim\limits_{n\to\infty} \frac{T(n)}{f(n)} = k
$$
即当 $ n $ 趋近于无限时，时间开销与 $ f(n) $ 的表达式之比应该是某个常数（对于时间复杂度只需要关注阶数高的那一项，并且去掉其系数即可）

基于这一原理可以推出以下两种计算准则

### **加法准则**

多项相加，只保留最高阶项，且系数变为1，其余项去除

表达式为：
$$
T(n) = T_1(n) + T_2(n) = O\big(f(n)\big) + O\big(g(n)\big) = O\Big(\max\big(f(n), g(n)\big)\Big)
$$
具体例子如：
$$
T(n) = n^3 + n^2 + 99999 = O(n^3) + O(n^2) + O(1) = O(n^3)
$$


### **乘法准则**

对于两个含有 $ n $ 的项相乘，对应的时间复杂度也需要进行相册

表达式为：
$$
T(n) = T_1(n) 
$$
