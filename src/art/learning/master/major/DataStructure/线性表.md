---
title: 线性表
icon: database
category: 
    - 数据结构
    - '408'
    - 考研
tag: 
    - c++
    - c
---

## 线性表的定义

线性表是具有**相同数据类型**的 n 个数据元素的**有限序列**，其中 n 为**表长**，当 n=0 时，称为空表，若用 L 表示线性表，则其一般表示为 $L = (a_1, a_2, \cdots , a_i, a_{i+1}, \cdots , a_n)$

这里需要注意的一些事项：

$a_i$ 的下标代表该元素在所在线性表中的第 $i$ 个位序，即第 $i$ 个元素

$a_1$ 称为**表头元素**， $a_n$ 称为**表尾元素** 

除第一个元素外，每个元素有且仅有一个**直接前驱元素**；除最后一个元素外，每个元素有且仅有一个**直接后继元素**

位序从 1 开始，数组下标从 0 开始

## 线性表的基本操作

`InitList(&L)`：初始化表。构造一个空的线性表L，分配内存空间

`DestroyList(&L)`：销毁操作。销毁线性表，并释放线性表L所占用的内存空间

`ListInsert(&L, i, e)`：插入操作。在表L中的第i个位置上插入指定元素e
`ListDelete(&L, i, &e)`：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值

`LocateElem(L, e)`：按值查找操作。在表L中查找具有给定关键字值的元素

`GetElem(L, i)`：按位查找操作。获取表L中第i个位置的元素的值。

其他常用操作：
`Length(L)`：求表长。返回线性表L的长度，即L中数据元素的个数

`PrintList(L)`：输出操作。按前后顺序输出线性表L的所有元素值

`Empty(L)`：判空操作。若L为空表，则返回true，否则返回false



**一些需要注意的点：**

- 对数据的操作（记忆思路）——创销、增删改查

- C语言函数的定义—— <返回值类型> 函数名（<参数1类型> 参数1，<参数2类型>参数2，……）

- 实际开发中，可根据实际需求定义其他的基本操作

- 函数名和参数的形式、命名都可改变（Reference:严蔚敏版《数据结构》）

- 什么时候要传入引用“&”——对参数的修改结果需要“带回来”

## 顺序表的存储结构（逻辑上和物理上）

### 顺序表

#### 顺序表的定义

用顺序存储的方式实现线性表顺序存储

把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现

具体表现为：

- 第一个元素在内存中存放的位置是`Loc(L)`

- 第二个元素在内存中存放的位置是`Loc(L)` + 数据元素大小

- 第三个元素在内存中存放的位置是`Loc(L)` + 数据元素大小 * 2

数据元素大小具体在C语言中的实现为使用`sizeof(ElemType)`函数，例如：`sizeof(int)`的输出结果为4（字节）

对于另外一个结构体的例子：

```c
typedef struct {
    int num; // 号数
    int people; // 人数
} Customer; // 定义了一个叫做Customer的类型

int main() {
    int size = sizeof(Customer)
    printf("%d", size); // 打印得 8
}
```

#### 顺序表的实现

- 静态分配

```c
#define MaxSize 10 // 宏定义最大长度
typedef struct {
    ElemType data[MaxSize]; // 使用静态的 “ 数组 ” 存放数据元素
    int length; // 顺序表的当前长度
} SqList; // 顺序表的类型定义（静态分配方式）
```

这样进行分配会造成存储空间很大程度的浪费，因此对于长度经常变化的数据需要使用动态分配

需要注意的是，访问表的内容时，不能直接通过访问数组，因为数组内的某些数据可能存在脏数据，正规的访问方式是，通过对应的访问方法来进行访问元素

- 动态分配
```c
#define InitSize 10 // 定义初始表的长度
typedef struct {
    ElemType *data; // 指示动态分配数组的指针（第一个元素的指针）
    int MaxSize; // 定义最大长度，因为表的长度是动态的，所以需要定义最大长度来进行限制
    int length; // 当前表长
}SeqList; // 顺序表的类型定义（动态分配方式）
```

需要注意的点是：

在C语言中，用于申请内存和释放内存的两个函数是：`malloc()`和`free()`，这两个函数都需要引入`stdlib.h`这个头文件

`malloc()`函数会开辟对应参数大小的连续的内存空间

而`free()`函数则会回收这一地址，`free()`函数的参数是一个指针，它会将指针所指的对应类型的内存空间进行释放

使用示例：

```c
#include<stdlib.h>
L.data = (ElemType * ) malloc(sizeof(ElemType) * InitSize); 
// 这里malloc返回的是一个指向开辟的内存地址起始位置的指针，需要强制转换成所需的数据元素的指针
// 这样这个指针就相当于指向这片内存中存储的第一个该数据元素的位置，然后将其赋值给表中的data
```

完整的链表方法演示：

```c
#include<stdlib.h>

#define InitSize 10 // 定义初始表的长度
typedef struct {
    int *data; // 指示动态分配数组的指针（第一个元素的指针）,这里假设是int类型
    int MaxSize; // 定义最大长度，因为表的长度是动态的，所以需要定义最大长度来进行限制
    int length; // 当前表长
}SeqList; // 顺序表的类型定义（动态分配方式）

void InitList(SeqList &L) {
    L.data = (int* ) malloc(sizeof(int) * InitSize); // 开辟空间
    L.MaxSize = InitSize; // 初始化最大长度
    L.length = 0; // 初始化表长
}

void IncreaseSize(SeqList &L, int len) {
    int *p = L.data; // 保存旧表的首地址
    L.data = (int* ) malloc(sizeof(int) * (L.MaxSize + len)); // 开辟新的空间
    for (int i = 0; i < L.length; i++) {
        L.data[i] = p[i]; // 将旧表中的数据复制到新表中
    }
    L.MaxSize = L.MaxSize + len; // 更新最大长度
    free(p); // 释放旧表的空间
}

int main() {
    SeqList L; // 声明一个顺序表
    InitList(L); // 初始化顺序表
    // ……随便插入几条数据
    IncreaseSize(L, 5); // 扩展顺序表
    return 0;
}
```

显而易见的，动态顺序表对于扩容有着强大的优势

#### 顺序表的特点

- 数据的随机访问：即可以在$O(1)$时间内找到第 i 个元素

- 存储密度高：每个节点只存储数据元素

- 扩展容量不方便：采用静态存储无法拓展容量，而采用动态存储则会耗费大量时间复制原本的数据

- 插入、删除操作不方便，需要移动大量元素

#### 顺序表的插入

需要实现的功能是：

`ListInsert(&L, i, e)`：插入操作。在表L中的第i个位置上插入指定元素e
