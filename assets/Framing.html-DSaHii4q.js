import{_ as s,c as t,e,o as n}from"./app-Bq2iESBq.js";const p={};function l(m,a){return n(),t("div",null,a[0]||(a[0]=[e('<h2 id="含义" tabindex="-1"><a class="header-anchor" href="#含义"><span>含义</span></a></h2><p>将上一层数据封装成帧的过程称为组帧</p><p>组帧的主要内容：</p><ul><li><p>帧定界：如何让接收方能够确定帧的界限</p></li><li><p>透明传输：接收方要能够去除“帧定界”的附加信息，把“帧”“恢复原貌”</p></li></ul><h2 id="四种组帧方法" tabindex="-1"><a class="header-anchor" href="#四种组帧方法"><span>四种组帧方法</span></a></h2><div class="hint-container warning"><p class="hint-container-title">注意</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>帧长</mtext><mo>=</mo><mtext>帧头长度</mtext><mo>+</mo><mtext>帧数据长度</mtext><mo>+</mo><mtext>帧尾长度</mtext><mo>=</mo><mtext>计数字段长度</mtext><mo>+</mo><mtext>数据长度</mtext></mrow><annotation encoding="application/x-tex"> \\text{帧长} = \\text{帧头长度} + \\text{帧数据长度} + \\text{帧尾长度} = \\text{计数字段长度} + \\text{数据长度} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">帧长</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord cjk_fallback">帧头长度</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord cjk_fallback">帧数据长度</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">帧尾长度</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord cjk_fallback">计数字段长度</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">数据长度</span></span></span></span></span></span></p></div><h3 id="字符计数法" tabindex="-1"><a class="header-anchor" href="#字符计数法"><span>字符计数法</span></a></h3><p>原理：在每个帧的开头，用一个<strong>定长计数字段</strong>表示帧长</p><p>最大缺点：任何一个计数字段出错，都会导致后续所有帧无法定界</p><h2 id="字节填充法" tabindex="-1"><a class="header-anchor" href="#字节填充法"><span>字节填充法</span></a></h2><p>原理：在数据头尾加上控制字符 SOH 和 EOT（Start of Header 和 End of Transmission），两字节之间的部分就为数字</p><ul><li><p>SOH</p><ul><li><p>二进制：00000001</p></li><li><p>十六进制：01H</p></li></ul></li><li><p>EOT</p><ul><li><p>二进制：00000100</p></li><li><p>十六进制：04H</p></li></ul></li></ul><p>对于数据内可能存在上述两种字符的情况，发送方会在发送前将数据内容包含的这两种字节数据前添加转义字符 ESC （Escape Character）（00011011），数据接收方会将转义字符去除，还原数据</p><p>同样的，如果数据中含有转义字符 ESC ，也需要在其前添加转义字符 ESC ，以防止数据接收方误判</p><p>总言之，当帧数据内部出现特殊字符时，需要在其前添加转义字符 ESC ，而数据接收方会对其进行逆操作</p><h3 id="零比特填充法" tabindex="-1"><a class="header-anchor" href="#零比特填充法"><span>零比特填充法</span></a></h3><p>原理：使用特殊比特串表示帧的开始和结束</p><ul><li><p>帧开始：01111110</p></li><li><p>帧结束：01111110</p></li></ul><p>和字节填充法一样，会遇到帧数据内部出现特殊字符的情况，对于这种情况</p><p>发送方需要对帧的数据进行处理：每当遇到连续的 5 个 1，就在其后面填充一个 0，</p><p>接收方也需要对帧的数据进行处理：每当遇到连续的 5 个 1，就将其后面的 0 去除</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>数据链路层中组帧使用这种协议的方法的协议：</p><ul><li><p>HDLC</p></li><li><p>PPP</p></li></ul></div><h3 id="违规编码法" tabindex="-1"><a class="header-anchor" href="#违规编码法"><span>违规编码法</span></a></h3><p>这种方法需要物理层的配合</p><p>原理：</p><p>在帧的开头和结尾，分别插入一个时钟周期的违规编码，比如在曼彻斯特编码中，每个编码在一个时钟周期内一定要发生一次跳变，在曼彻斯特编码传输的数据下，我们可以在开头和结尾插入一个周期不跳变的信号作为违规编码来标记帧的数据部分</p>',26)]))}const r=s(p,[["render",l]]),c=JSON.parse('{"path":"/art/learning/master/major/ComputerNetworks/Framing.html","title":"组帧","lang":"zh-CN","frontmatter":{"title":"组帧","date":"2025-05-31T00:00:00.000Z","icon":"earth-americas","order":14,"category":["408","计算机网络","考研"],"description":"含义 将上一层数据封装成帧的过程称为组帧 组帧的主要内容： 帧定界：如何让接收方能够确定帧的界限 透明传输：接收方要能够去除“帧定界”的附加信息，把“帧”“恢复原貌” 四种组帧方法 注意 帧长=帧头长度+帧数据长度+帧尾长度=计数字段长度+数据长度 字符计数法 原理：在每个帧的开头，用一个定长计数字段表示帧长 最大缺点：任何一个计数字段出错，都会导致后...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"组帧\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-05-31T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-04T11:13:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KurimulaAiri\\",\\"url\\":\\"https://github.com/KurimulaAiri\\"}]}"],["meta",{"property":"og:url","content":"https://md.s1r0ko.top/art/learning/master/major/ComputerNetworks/Framing.html"}],["meta",{"property":"og:site_name","content":"博客与资料库"}],["meta",{"property":"og:title","content":"组帧"}],["meta",{"property":"og:description","content":"含义 将上一层数据封装成帧的过程称为组帧 组帧的主要内容： 帧定界：如何让接收方能够确定帧的界限 透明传输：接收方要能够去除“帧定界”的附加信息，把“帧”“恢复原貌” 四种组帧方法 注意 帧长=帧头长度+帧数据长度+帧尾长度=计数字段长度+数据长度 字符计数法 原理：在每个帧的开头，用一个定长计数字段表示帧长 最大缺点：任何一个计数字段出错，都会导致后..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-04T11:13:14.000Z"}],["meta",{"property":"article:published_time","content":"2025-05-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-04T11:13:14.000Z"}]]},"git":{"createdTime":1748707952000,"updatedTime":1749035594000,"contributors":[{"name":"KurimulaAiri","username":"KurimulaAiri","email":"1095370199@qq.com","commits":2,"url":"https://github.com/KurimulaAiri"}],"changelog":[{"hash":"75e9a88a22dd208ba7624996436c281cfc544e80","time":1749035594000,"email":"1095370199@qq.com","author":"KurimulaAiri","message":"修订"},{"hash":"2a82e8c9a4ee17ad93ae5ad7b574ead82b0606aa","time":1748707952000,"email":"1095370199@qq.com","author":"KurimulaAiri","message":"新增之前的部分文章"}]},"readingTime":{"minutes":2.23,"words":668},"filePathRelative":"art/learning/master/major/ComputerNetworks/Framing.md","excerpt":"<h2>含义</h2>\\n<p>将上一层数据封装成帧的过程称为组帧</p>\\n<p>组帧的主要内容：</p>\\n<ul>\\n<li>\\n<p>帧定界：如何让接收方能够确定帧的界限</p>\\n</li>\\n<li>\\n<p>透明传输：接收方要能够去除“帧定界”的附加信息，把“帧”“恢复原貌”</p>\\n</li>\\n</ul>\\n<h2>四种组帧方法</h2>\\n<div class=\\"hint-container warning\\">\\n<p class=\\"hint-container-title\\">注意</p>\\n<p v-pre=\\"\\" class=\\"katex-block\\"><span class=\\"katex-display\\"><span class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\" display=\\"block\\"><semantics><mrow><mtext>帧长</mtext><mo>=</mo><mtext>帧头长度</mtext><mo>+</mo><mtext>帧数据长度</mtext><mo>+</mo><mtext>帧尾长度</mtext><mo>=</mo><mtext>计数字段长度</mtext><mo>+</mo><mtext>数据长度</mtext></mrow><annotation encoding=\\"application/x-tex\\">\\n\\\\text{帧长} = \\\\text{帧头长度} + \\\\text{帧数据长度} + \\\\text{帧尾长度} = \\\\text{计数字段长度} + \\\\text{数据长度}\\n\\n</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6833em;\\"></span><span class=\\"mord text\\"><span class=\\"mord cjk_fallback\\">帧长</span></span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span><span class=\\"mrel\\">=</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.7667em;vertical-align:-0.0833em;\\"></span><span class=\\"mord text\\"><span class=\\"mord cjk_fallback\\">帧头长度</span></span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.7667em;vertical-align:-0.0833em;\\"></span><span class=\\"mord text\\"><span class=\\"mord cjk_fallback\\">帧数据长度</span></span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6833em;\\"></span><span class=\\"mord text\\"><span class=\\"mord cjk_fallback\\">帧尾长度</span></span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span><span class=\\"mrel\\">=</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.7667em;vertical-align:-0.0833em;\\"></span><span class=\\"mord text\\"><span class=\\"mord cjk_fallback\\">计数字段长度</span></span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.6833em;\\"></span><span class=\\"mord text\\"><span class=\\"mord cjk_fallback\\">数据长度</span></span></span></span></span></span></p>\\n</div>","autoDesc":true}');export{r as comp,c as data};
