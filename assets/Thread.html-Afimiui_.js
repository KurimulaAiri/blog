import{_ as e,c as a,d as r,o as n}from"./app-BxOLPT2u.js";const s={};function i(l,t){return n(),a("div",null,t[0]||(t[0]=[r('<h2 id="线程的概念" tabindex="-1"><a class="header-anchor" href="#线程的概念"><span>线程的概念</span></a></h2><p>在没引入线程的概念之前，所有应用只能串行运行</p><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p><p>传统进程是程序执行流的最小单位，引入线程后，线程成为了程序执行流的<strong>最小单位</strong>，可以把线程理解为“轻量级进程”</p><p><strong>线程</strong>是一个<strong>基本的 CPU 执行单元</strong>，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的<strong>各线程之间也可以并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内也可以并发处理各种任务（如 QQ 视频、文字聊天、传文件等）</p><p>引入线程后，<strong>进程只作为除 CPU 之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）</p><h2 id="引入线程后与之前的区别" tabindex="-1"><a class="header-anchor" href="#引入线程后与之前的区别"><span>引入线程后与之前的区别</span></a></h2><table><thead><tr><th style="text-align:center;">对比点</th><th style="text-align:center;">进程</th><th style="text-align:center;">线程</th></tr></thead><tbody><tr><td style="text-align:center;">资源分配、调度</td><td style="text-align:center;">进程是资源分配、调度的基本单位</td><td style="text-align:center;">进程是资源分配的基本单位，线程是调度的基本单位</td></tr><tr><td style="text-align:center;">并发性</td><td style="text-align:center;">只能进程间并发</td><td style="text-align:center;">各线程间也能并发，提升了并发度</td></tr><tr><td style="text-align:center;">系统开销</td><td style="text-align:center;">进程间并发，需要切换进程的运行环境，系统开销很大</td><td style="text-align:center;">线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小，引入线程后，并发所带来的系统开销减小</td></tr></tbody></table><h2 id="线程的属性" tabindex="-1"><a class="header-anchor" href="#线程的属性"><span>线程的属性</span></a></h2><ol><li>线程是处理机调度的单位</li><li>多 CPU 计算机中，各个线程可占用不同的 CPU （可以是同一个 CPU 的不同核心，也可以是不同的 CPU ）</li><li>每个线程都有一个线程 ID 、线程控制块（ TCB ）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ol><h2 id="线程的实现方式" tabindex="-1"><a class="header-anchor" href="#线程的实现方式"><span>线程的实现方式</span></a></h2><p>线程主要有两种实现方式：用户级线程（ User-Level Thread ， ULT ）和内核级线程（ Kernel-Level Thread ， KLT 又称“内核支持的线程”）</p><h3 id="用户级线程" tabindex="-1"><a class="header-anchor" href="#用户级线程"><span>用户级线程</span></a></h3><p>历史背景：早期的操作系统（如：早期 Unix ）只支持进程不支持线程。当时的“线程”是由线程库实现的</p><p>很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。</p><ul><li>线程的管理工作由谁来完成？</li></ul><p>用户级线程由应用程序通过线程库实现，<strong id="blue-msg">所有的线程管理工作都由应用程序负责</strong>（包括线程切换）</p><ul><li>线程切换是否需要 CPU 变换状态？</li></ul><p>用户级线程中，<strong id="blue-msg">线程切换可以在用户态下即可完成</strong>，无需操作系统干预</p><ul><li>操作系统是否能意识到用户级线程的存在？</li></ul><p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。<strong id="blue-msg">“用户级线程”就是“从用户视角看能看到的线程”</strong></p><ul><li><p>这种线程的实现方式有什么优点和缺点？</p><ul><li><p>优点<br> 用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p></li><li><p>缺点<br> 当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高<br> 多个线程不可在多核处理机上并行运行</p></li></ul></li></ul><h3 id="内核级线程" tabindex="-1"><a class="header-anchor" href="#内核级线程"><span>内核级线程</span></a></h3><p>由操作系统支持的线程，大多数现代操作系统都实现了内核级线程，如 Windows 、 Linux 等</p><ul><li>线程的管理工作由谁来完成？</li></ul><p><strong id="blue-msg">内核级线程的管理工作由操作系统内核完成</strong></p><ul><li>线程切换是否需要 CPU 切换状态？</li></ul><p>线程调度、切换等工作都由内核负责，因此<strong id="blue-msg">内核级线程的切换必然需要在核心态</strong>下才能完成</p><ul><li>操作系统是否能意识到内核级线程的存在？</li></ul><p>操作系统会为每个内核级线程建立相应的 TCB （ ThreadControlBlock ，线程控制块）通过 TCB 对线程进行管理。<strong id="blue-msg">“内核级线程”就是“从操作系统内核视角看能看到的线程”</strong></p><ul><li><p>这种线程的实现方式有什么优点和缺点？</p><ul><li><p>优点<br> 当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行</p></li><li><p>缺点<br> 一个用户进程会占用多个内核级线程线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</p></li></ul></li></ul><h2 id="多线程模型" tabindex="-1"><a class="header-anchor" href="#多线程模型"><span>多线程模型</span></a></h2><p>为了结合两种线程的优点，引入了多线程模型</p><p>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型</p><h3 id="一对一模型" tabindex="-1"><a class="header-anchor" href="#一对一模型"><span>一对一模型</span></a></h3><p>一个用户级线程映射到一个内核级线程<br> 每个用户进程有与用户级线程同数量的内核级线程</p><ul><li>优点</li></ul><p>当一个线程被阻塞后，别的线程还可以继续执行，并发能力强<br> 多线程可在多核处理机上并行执行</p><ul><li>缺点</li></ul><p>一个用户进程会占用多个内核级线程线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</p><h3 id="多对一模型" tabindex="-1"><a class="header-anchor" href="#多对一模型"><span>多对一模型</span></a></h3><p>多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程</p><ul><li>优点</li></ul><p>用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p><ul><li>缺点</li></ul><p>当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p><strong id="red-msg">操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位</strong></p></div><h3 id="多对多模型" tabindex="-1"><a class="header-anchor" href="#多对多模型"><span>多对多模型</span></a></h3><figure><img src="//store.s1r0ko.top/svg/m/os/12/1_ver_1.svg" alt="多对多模型" tabindex="0" loading="lazy"><figcaption>多对多模型</figcaption></figure><p>n 个用户级线程映射到 m 个内核级线程（ n <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span> m ）。每个用户进程对应 m 个内核级线程</p><p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</p><p>可以这么理解:<br> 用户级线程是“代码逻辑”的载体<br> 内核级线程是“运行机会”的载体</p><p>内核级线程才是处理机分配的单位。例如:多核 CPU 环境下，上边这个进程最多能被分配两个核</p><p>一段“代码逻辑”只有获得了“运行机会”才能被 CPU 执行</p><p>内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞</p><h2 id="线程的状态与转换" tabindex="-1"><a class="header-anchor" href="#线程的状态与转换"><span>线程的状态与转换</span></a></h2><p>线程的状态与转换与进程的状态与转换完全一致</p><figure><img src="//store.s1r0ko.top/svg/m/os/12/2_ver_1.svg" alt="线程的状态与转换" tabindex="0" loading="lazy"><figcaption>线程的状态与转换</figcaption></figure><h2 id="线程的组织与控制" tabindex="-1"><a class="header-anchor" href="#线程的组织与控制"><span>线程的组织与控制</span></a></h2><figure><img src="//store.s1r0ko.top/svg/m/os/12/3_ver_1.svg" alt="线程的组织与控制" tabindex="0" loading="lazy"><figcaption>线程的组织与控制</figcaption></figure><p>与进程类似，线程的各种信息保存在线程控制块（ Thread Control Block ， TCB ）中</p><p>线程的各个 TCB 可以按照状态，进程，或者系统统一划分为线程表，各个操作系统不同</p>',62)]))}const o=e(s,[["render",i]]),g=JSON.parse('{"path":"/art/learning/master/major/OperatingSystem/Thread.html","title":"线程","lang":"zh-CN","frontmatter":{"title":"线程","date":"2025-08-21T00:00:00.000Z","icon":"gears","order":12,"category":["408","操作系统","考研"],"description":"线程的概念 在没引入线程的概念之前，所有应用只能串行运行 有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。 传统进程是程序执行流的最小单位，引入线程后，线程成为了程序执行流的最小单位，可以把线程理解为“轻量级进程” 线程是一个基本的 CPU 执行单元，也是程序执行流的最小单位。引入线程之后，不...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"线程\\",\\"image\\":[\\"//store.s1r0ko.top/svg/m/os/12/1_ver_1.svg\\",\\"//store.s1r0ko.top/svg/m/os/12/2_ver_1.svg\\",\\"//store.s1r0ko.top/svg/m/os/12/3_ver_1.svg\\"],\\"datePublished\\":\\"2025-08-21T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T09:57:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KurimulaAiri\\",\\"url\\":\\"https://github.com/KurimulaAiri\\"}]}"],["meta",{"property":"og:url","content":"https://md.s1r0ko.top/art/learning/master/major/OperatingSystem/Thread.html"}],["meta",{"property":"og:site_name","content":"博客与资料库"}],["meta",{"property":"og:title","content":"线程"}],["meta",{"property":"og:description","content":"线程的概念 在没引入线程的概念之前，所有应用只能串行运行 有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。 传统进程是程序执行流的最小单位，引入线程后，线程成为了程序执行流的最小单位，可以把线程理解为“轻量级进程” 线程是一个基本的 CPU 执行单元，也是程序执行流的最小单位。引入线程之后，不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"//store.s1r0ko.top/svg/m/os/12/1_ver_1.svg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T09:57:19.000Z"}],["meta",{"property":"article:published_time","content":"2025-08-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T09:57:19.000Z"}]]},"git":{"createdTime":1755684230000,"updatedTime":1755856639000,"contributors":[{"name":"KurimulaAiri","username":"KurimulaAiri","email":"1095370199@qq.com","commits":3,"url":"https://github.com/KurimulaAiri"}]},"readingTime":{"minutes":6.96,"words":2087},"filePathRelative":"art/learning/master/major/OperatingSystem/Thread.md","excerpt":"<h2>线程的概念</h2>\\n<p>在没引入线程的概念之前，所有应用只能串行运行</p>\\n<p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p>\\n<p>传统进程是程序执行流的最小单位，引入线程后，线程成为了程序执行流的<strong>最小单位</strong>，可以把线程理解为“轻量级进程”</p>\\n<p><strong>线程</strong>是一个<strong>基本的 CPU 执行单元</strong>，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的<strong>各线程之间也可以并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内也可以并发处理各种任务（如 QQ 视频、文字聊天、传文件等）</p>","autoDesc":true}');export{o as comp,g as data};
