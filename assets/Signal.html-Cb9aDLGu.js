import{_ as e,c as n,d as i,o as l}from"./app-CZSc8niw.js";const a={};function r(s,t){return l(),n("div",null,t[0]||(t[0]=[i('<h2 id="信号和信号量" tabindex="-1"><a class="header-anchor" href="#信号和信号量"><span>信号和信号量</span></a></h2><p>信号量（ Semaphore ） —— 实现进程间的同步、互斥</p><p>信号（ Signal ） —— 实现进程间通信（ IPC ， Inter Process Communication ）</p><p>考研大纲将信号定义为一种进程间的通信方式</p><h2 id="信号的作用" tabindex="-1"><a class="header-anchor" href="#信号的作用"><span>信号的作用</span></a></h2><p>信号（ signal ）：用于<strong>通知进程某个特定事件已经发生</strong>。进程收到一个信号后，对该信号进行处理</p><div class="hint-container warning"><p class="hint-container-title">注意</p><ol><li>不同的操作系统对信号类型的定义不一样</li><li>通常用宏定义常量表示信号名，如：<code>#define SIGINT 2</code></li></ol></div><h2 id="信号的实现原理" tabindex="-1"><a class="header-anchor" href="#信号的实现原理"><span>信号的实现原理</span></a></h2><h3 id="发送与保存" tabindex="-1"><a class="header-anchor" href="#发送与保存"><span>发送与保存</span></a></h3><p>在进程 PCB 中通常会维护一张位向量表，用于表示当前未处理的信号</p><p>其结构大概如此：</p><p>一个信号类型对应的一个<strong>待处理信号</strong> / <strong>被阻塞信号</strong>占 1 位</p><table><thead><tr><th style="text-align:center;">信号类型</th><th style="text-align:center;">1</th><th style="text-align:center;">2</th><th style="text-align:center;">3</th><th style="text-align:center;">4</th><th style="text-align:center;">5</th><th style="text-align:center;">6</th><th style="text-align:center;">7</th><th style="text-align:center;">……</th></tr></thead><tbody><tr><td style="text-align:center;">待处理信号 pending</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">……</td></tr><tr><td style="text-align:center;">被阻塞信号 blocked</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td><td style="text-align:center;">……</td></tr></tbody></table><p>blocked 也可以被称为信号掩码，对应信号位为 1 代表该进程阻塞（屏蔽）该种信号，表格中为 6 、 7 号信号被屏蔽<br> 进程可以通过系统调用来设置信号掩码</p><p>用户进程和内核进程都可以使用 <code>int kill(pid_t pid, int sig)</code> 来向用户进程发送信号，但用户进程发送的信号类型是有限制的</p><ul><li>pid ：进程 ID</li><li>sig ：信号类型</li></ul><p>向对应进程发送该指令，该进程会将向量表内的 pending 对应信号位设置为 1</p><p>如果多个 kill 指令到达同一个进程，该进程只会记录一次，后续的 kill 指令不会再改变 pending 位</p><h3 id="处理" tabindex="-1"><a class="header-anchor" href="#处理"><span>处理</span></a></h3><ul><li><strong id="blue-msg">何时处理信号</strong></li></ul><p>当进程从<strong>内核态转为用户态时</strong>（如：系统调用返回、或中断处理返回时），例行检查是否有待处理信号，如果有，就处理信号</p><ul><li><strong id="blue-msg">处理哪种信号</strong></li></ul><p>在处理信号前，先检查信号是否被阻塞</p><p>将 blocked 位向量取出全部取反，与 pending 位进行与操作，对于结果为 1 的位对应的信号进行处理，其他则处理</p><p>用上面的例子解释：</p><ol><li>假设某进程向该进程传递 1 和 7 号信号</li><li>该进程的 blocked 位向量为 0000011，pending 位为 1000001</li><li>blocked 取反后为 1111100</li><li>与 pending 位进行与操作，1111100 &amp; 1000001 = 1000000</li><li>结果为 1000000</li><li>因此，该进程会调用对应处理 1 号信号的方法处理 1 号信号</li></ol><ul><li><strong id="blue-msg">如何处理信号</strong></li></ul><p>① 执行操作系统为此类信号设置的缺省（默认）信号处理程序（某些信号默认忽略，不作处理）</p><p>② 执行进程为此类信号设置用户自定义信号处理程序（自定义信号处理程序将覆盖 ① ）</p><ul><li><p>信号处理程序运行结束后，通常会返回进程的下一条指令继续执行（除非信号处理程序将进程阻塞或终止）</p></li><li><p>一旦处理了某个信号，就将 pending 位重置为 0</p></li><li><p>重复收到的同类信号，将被简单地丢弃（因为仅有 1 bit 记录一类待处理信号）<br> 当同时收到多个不同类信号时，通常先处理序号更小的信号</p></li></ul><h2 id="各个进程的信号处理有何区别" tabindex="-1"><a class="header-anchor" href="#各个进程的信号处理有何区别"><span>各个进程的信号处理有何区别？</span></a></h2><ul><li><p>对信号的阻塞不同</p></li><li><p>对信号的自定义处理不同</p></li><li><p>各自对信号的处理互相独立不受影响</p></li></ul><h2 id="信号和异常的关系" tabindex="-1"><a class="header-anchor" href="#信号和异常的关系"><span>信号和异常的关系</span></a></h2><p>“信号”可以作为“异常”的配套机制，让进程对操作系统的异常处理进行补充</p><p>在进程运行过程中，某些特殊事件可能引发“异常”，操作系统内核负责捕获并处理异常</p><ul><li><p>有些异常可以由内核完成全部处理（如：缺页异常），此时就不必再使用信号机制。</p></li><li><p><strong>有些异常无法由内核完成全部处理，可能还需要用户进程配合</strong>，此时就可以用“信号机制”与“异常机制”相互配合（如：在 Linux 中，发生除以 0 异常时，内核的异常处理程序会向用户进程发送 SIGFPE 信号。SIGFPE 信号的默认处理程序会将进程终止并转储内存；当然进程可以自定义 SIGFPE 信号处理程序）</p></li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><p><strong id="red-msg">有些信号不允许用户进程自定义处理程序</strong>，也不能被阻塞，如：</p><ul><li>SIGKILL</li><li>SIGSTOP</li></ul></div>',37)]))}const o=e(a,[["render",r]]),d=JSON.parse('{"path":"/art/learning/master/major/OperatingSystem/Signal.html","title":"信号","lang":"zh-CN","frontmatter":{"title":"信号","date":"2025-08-20T00:00:00.000Z","icon":"gears","order":11,"category":["408","操作系统","考研"],"description":"信号和信号量 信号量（ Semaphore ） —— 实现进程间的同步、互斥 信号（ Signal ） —— 实现进程间通信（ IPC ， Inter Process Communication ） 考研大纲将信号定义为一种进程间的通信方式 信号的作用 信号（ signal ）：用于通知进程某个特定事件已经发生。进程收到一个信号后，对该信号进行处理 注...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"信号\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-08-20T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-20T10:03:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KurimulaAiri\\",\\"url\\":\\"https://github.com/KurimulaAiri\\"}]}"],["meta",{"property":"og:url","content":"https://md.s1r0ko.top/art/learning/master/major/OperatingSystem/Signal.html"}],["meta",{"property":"og:site_name","content":"博客与资料库"}],["meta",{"property":"og:title","content":"信号"}],["meta",{"property":"og:description","content":"信号和信号量 信号量（ Semaphore ） —— 实现进程间的同步、互斥 信号（ Signal ） —— 实现进程间通信（ IPC ， Inter Process Communication ） 考研大纲将信号定义为一种进程间的通信方式 信号的作用 信号（ signal ）：用于通知进程某个特定事件已经发生。进程收到一个信号后，对该信号进行处理 注..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-20T10:03:50.000Z"}],["meta",{"property":"article:published_time","content":"2025-08-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-20T10:03:50.000Z"}]]},"git":{"createdTime":1755684230000,"updatedTime":1755684230000,"contributors":[{"name":"KurimulaAiri","username":"KurimulaAiri","email":"1095370199@qq.com","commits":1,"url":"https://github.com/KurimulaAiri"}],"changelog":[{"hash":"e023dc1f4190d361ad0df6e01522a85bb1e79ffc","time":1755684230000,"email":"1095370199@qq.com","author":"KurimulaAiri","message":"新增两篇"}]},"readingTime":{"minutes":3.83,"words":1149},"filePathRelative":"art/learning/master/major/OperatingSystem/Signal.md","excerpt":"<h2>信号和信号量</h2>\\n<p>信号量（ Semaphore ） —— 实现进程间的同步、互斥</p>\\n<p>信号（ Signal ） —— 实现进程间通信（ IPC ， Inter Process Communication ）</p>\\n<p>考研大纲将信号定义为一种进程间的通信方式</p>\\n<h2>信号的作用</h2>\\n<p>信号（ signal ）：用于<strong>通知进程某个特定事件已经发生</strong>。进程收到一个信号后，对该信号进行处理</p>\\n<div class=\\"hint-container warning\\">\\n<p class=\\"hint-container-title\\">注意</p>\\n<ol>\\n<li>不同的操作系统对信号类型的定义不一样</li>\\n<li>通常用宏定义常量表示信号名，如：<code>#define SIGINT 2</code></li>\\n</ol>\\n</div>","autoDesc":true}');export{o as comp,d as data};
