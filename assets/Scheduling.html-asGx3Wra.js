import{_ as e,c as n,b as r,o as s}from"./app-BoSlJUxS.js";const a={};function i(o,t){return s(),n("div",null,t[0]||(t[0]=[r('<h2 id="调度的概念" tabindex="-1"><a class="header-anchor" href="#调度的概念"><span>调度的概念</span></a></h2><p>当有大量任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题</p><h2 id="调度的三个层次" tabindex="-1"><a class="header-anchor" href="#调度的三个层次"><span>调度的三个层次</span></a></h2><h3 id="高级调度" tabindex="-1"><a class="header-anchor" href="#高级调度"><span>高级调度</span></a></h3><p>内存空间有限，有时无法将用户提交的作业全部放入内存</p><p><strong id="blue-msg">高级调度（作业调度）</strong> —— 按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<strong id="red-msg">每个作业只调入一次，调出一次</strong>。作业调入时会建立 PCB ，调出时才撤销 PCB</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>作业：一个具体的任务</p><p>用户向系统提交一个作业 = 用户让操作系统启动一个程序（来处理一个具体的任务）</p></div><h3 id="低级调度" tabindex="-1"><a class="header-anchor" href="#低级调度"><span>低级调度</span></a></h3><p><strong id="blue-msg">低级调度（进程调度 / 处理机调度）</strong> —— 按照某种策略从就绪队列中选取一个进程，将处理机分配给它</p><p>进程调度是操作系统中<strong id="blue-msg">最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度进程调度的<strong id="blue-msg">频率很高</strong>，一般几十毫秒一次</p><h3 id="中级调度" tabindex="-1"><a class="header-anchor" href="#中级调度"><span>中级调度</span></a></h3><p>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存</p><p>暂时调到外存等待的进程状态为<strong id="blue-msg">挂起状态</strong>。被挂起的进程 PCB 会被组织成<strong id="blue-msg">挂起队列</strong></p><p><strong id="blue-msg">中级调度（内存调度）</strong> —— 按照某种策略决定将哪个处于挂起状态的进程重新调入内存<br> 一个进程可能会被多次调出、调入内存，因此<strong id="blue-msg">中级调度发生的频率要比高级调度更高</strong></p><h3 id="七状态模型" tabindex="-1"><a class="header-anchor" href="#七状态模型"><span>* 七状态模型</span></a></h3><p><strong id="red-msg">考 408 仅了解，不要求记忆</strong></p><p>暂时调到外存等待的进程状态为<strong id="blue-msg">挂起状态（挂起态， suspend ）</strong><br> 挂起态又可以进一步细分为<strong id="blue-msg">就绪挂起、阻塞挂起</strong>两种状态</p><p><strong id="blue-msg">就绪挂起态（ ready-suspend ）</strong>是指在就绪队列中等待的进程被移入外存中，<strong id="blue-msg">阻塞挂起态（ block-suspend ）</strong>亦然</p><p><strong id="blue-msg">阻塞挂起态</strong>和就绪挂起态的进程可以在特定条件发生时激活并重新返回对应的队列中，某些操作系统中，处于<strong id="blue-msg">阻塞挂起态</strong>的进程在等待到对应事件发生后也可以切换成<strong id="blue-msg">就绪挂起状态</strong></p><p>同样在某些操作系统中，刚创建完成的进程或<strong id="blue-msg">运行态</strong>的进程在下处理机后会切换为<strong id="blue-msg">就绪挂起态</strong></p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得 CPU 的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中</p><p>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列</p></div><h3 id="三种调度的联系和对比" tabindex="-1"><a class="header-anchor" href="#三种调度的联系和对比"><span>三种调度的联系和对比</span></a></h3><table><thead><tr><th style="text-align:center;">调度类型 / 对比项</th><th style="text-align:center;">要做什么</th><th style="text-align:center;">调度发生在哪</th><th style="text-align:center;">发生频率</th><th style="text-align:center;">对进程状态的影响</th></tr></thead><tbody><tr><td style="text-align:center;">高级调度（作业调度）</td><td style="text-align:center;">按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td style="text-align:center;">外存→内存（面向作业）</td><td style="text-align:center;">最低</td><td style="text-align:center;">无→创建态→就绪态</td></tr><tr><td style="text-align:center;">低级调度（内存调度）</td><td style="text-align:center;">按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td><td style="text-align:center;">外存→内存（面向进程）</td><td style="text-align:center;">中等</td><td style="text-align:center;">挂起态→就绪态（阻塞挂起→阻塞态）</td></tr><tr><td style="text-align:center;">中级调度（进程调度）</td><td style="text-align:center;">按照某种规则，从就绪队列中选择一个进程为其分配处理机</td><td style="text-align:center;">内存→ CPU</td><td style="text-align:center;">最高</td><td style="text-align:center;">就绪态→运行态</td></tr></tbody></table>',23)]))}const l=e(a,[["render",i]]),g=JSON.parse('{"path":"/art/learning/master/major/OperatingSystem/Scheduling.html","title":"调度","lang":"zh-CN","frontmatter":{"title":"调度","date":"2025-08-22T00:00:00.000Z","icon":"gears","order":13,"category":["408","操作系统","考研"],"description":"调度的概念 当有大量任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题 调度的三个层次 高级调度 内存空间有限，有时无法将用户提交的作业全部放入内存 高级调度（作业调度） —— 按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"调度\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-08-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T09:57:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KurimulaAiri\\",\\"url\\":\\"https://github.com/KurimulaAiri\\"}]}"],["meta",{"property":"og:url","content":"https://md.s1r0ko.top/art/learning/master/major/OperatingSystem/Scheduling.html"}],["meta",{"property":"og:site_name","content":"博客与资料库"}],["meta",{"property":"og:title","content":"调度"}],["meta",{"property":"og:description","content":"调度的概念 当有大量任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题 调度的三个层次 高级调度 内存空间有限，有时无法将用户提交的作业全部放入内存 高级调度（作业调度） —— 按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T09:57:19.000Z"}],["meta",{"property":"article:published_time","content":"2025-08-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T09:57:19.000Z"}]]},"git":{"createdTime":1755856639000,"updatedTime":1755856639000,"contributors":[{"name":"KurimulaAiri","username":"KurimulaAiri","email":"1095370199@qq.com","commits":1,"url":"https://github.com/KurimulaAiri"}]},"readingTime":{"minutes":3.44,"words":1033},"filePathRelative":"art/learning/master/major/OperatingSystem/Scheduling.md","excerpt":"<h2>调度的概念</h2>\\n<p>当有大量任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题</p>\\n<h2>调度的三个层次</h2>\\n<h3>高级调度</h3>\\n<p>内存空间有限，有时无法将用户提交的作业全部放入内存</p>\\n<p><strong id=\\"blue-msg\\">高级调度（作业调度）</strong> —— 按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<strong id=\\"red-msg\\">每个作业只调入一次，调出一次</strong>。作业调入时会建立 PCB ，调出时才撤销 PCB</p>","autoDesc":true}');export{l as comp,g as data};
